"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-material-symbols";
exports.ids = ["vendor-chunks/react-material-symbols"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-material-symbols/dist/rounded.css":
/*!**************************************************************!*\
  !*** ./node_modules/react-material-symbols/dist/rounded.css ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"602dfef159d3\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWF0ZXJpYWwtc3ltYm9scy9kaXN0L3JvdW5kZWQuY3NzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjO0FBQzdCLElBQUksS0FBVSxFQUFFLEVBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2FsbGV0LXJvbmluLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW1hdGVyaWFsLXN5bWJvbHMvZGlzdC9yb3VuZGVkLmNzcz81YmJjIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiNjAyZGZlZjE1OWQzXCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-material-symbols/dist/rounded.css\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-material-symbols/dist/index.es.js":
/*!**************************************************************!*\
  !*** ./node_modules/react-material-symbols/dist/index.es.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MaterialSymbol: () => (/* binding */ qt)\n/* harmony export */ });\nvar Lr = { exports: {} }, Ge = {}, Vr = { exports: {} }, g = {};\n/**\n * @license React\n * react.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar ft;\nfunction Nt() {\n  if (ft)\n    return g;\n  ft = 1;\n  var Y = Symbol.for(\"react.element\"), v = Symbol.for(\"react.portal\"), pe = Symbol.for(\"react.fragment\"), G = Symbol.for(\"react.strict_mode\"), ne = Symbol.for(\"react.profiler\"), ee = Symbol.for(\"react.provider\"), H = Symbol.for(\"react.context\"), K = Symbol.for(\"react.forward_ref\"), D = Symbol.for(\"react.suspense\"), J = Symbol.for(\"react.memo\"), I = Symbol.for(\"react.lazy\"), W = Symbol.iterator;\n  function X(n) {\n    return n === null || typeof n != \"object\" ? null : (n = W && n[W] || n[\"@@iterator\"], typeof n == \"function\" ? n : null);\n  }\n  var k = { isMounted: function() {\n    return !1;\n  }, enqueueForceUpdate: function() {\n  }, enqueueReplaceState: function() {\n  }, enqueueSetState: function() {\n  } }, fe = Object.assign, Ie = {};\n  function ae(n, s, h) {\n    this.props = n, this.context = s, this.refs = Ie, this.updater = h || k;\n  }\n  ae.prototype.isReactComponent = {}, ae.prototype.setState = function(n, s) {\n    if (typeof n != \"object\" && typeof n != \"function\" && n != null)\n      throw Error(\"setState(...): takes an object of state variables to update or a function which returns an object of state variables.\");\n    this.updater.enqueueSetState(this, n, s, \"setState\");\n  }, ae.prototype.forceUpdate = function(n) {\n    this.updater.enqueueForceUpdate(this, n, \"forceUpdate\");\n  };\n  function oe() {\n  }\n  oe.prototype = ae.prototype;\n  function L(n, s, h) {\n    this.props = n, this.context = s, this.refs = Ie, this.updater = h || k;\n  }\n  var he = L.prototype = new oe();\n  he.constructor = L, fe(he, ae.prototype), he.isPureReactComponent = !0;\n  var ie = Array.isArray, N = Object.prototype.hasOwnProperty, Q = { current: null }, ce = { key: !0, ref: !0, __self: !0, __source: !0 };\n  function ve(n, s, h) {\n    var C, _ = {}, P = null, j = null;\n    if (s != null)\n      for (C in s.ref !== void 0 && (j = s.ref), s.key !== void 0 && (P = \"\" + s.key), s)\n        N.call(s, C) && !ce.hasOwnProperty(C) && (_[C] = s[C]);\n    var T = arguments.length - 2;\n    if (T === 1)\n      _.children = h;\n    else if (1 < T) {\n      for (var w = Array(T), U = 0; U < T; U++)\n        w[U] = arguments[U + 2];\n      _.children = w;\n    }\n    if (n && n.defaultProps)\n      for (C in T = n.defaultProps, T)\n        _[C] === void 0 && (_[C] = T[C]);\n    return { $$typeof: Y, type: n, key: P, ref: j, props: _, _owner: Q.current };\n  }\n  function Re(n, s) {\n    return { $$typeof: Y, type: n.type, key: s, ref: n.ref, props: n.props, _owner: n._owner };\n  }\n  function Ce(n) {\n    return typeof n == \"object\" && n !== null && n.$$typeof === Y;\n  }\n  function Ue(n) {\n    var s = { \"=\": \"=0\", \":\": \"=2\" };\n    return \"$\" + n.replace(/[=:]/g, function(h) {\n      return s[h];\n    });\n  }\n  var we = /\\/+/g;\n  function Z(n, s) {\n    return typeof n == \"object\" && n !== null && n.key != null ? Ue(\"\" + n.key) : s.toString(36);\n  }\n  function re(n, s, h, C, _) {\n    var P = typeof n;\n    (P === \"undefined\" || P === \"boolean\") && (n = null);\n    var j = !1;\n    if (n === null)\n      j = !0;\n    else\n      switch (P) {\n        case \"string\":\n        case \"number\":\n          j = !0;\n          break;\n        case \"object\":\n          switch (n.$$typeof) {\n            case Y:\n            case v:\n              j = !0;\n          }\n      }\n    if (j)\n      return j = n, _ = _(j), n = C === \"\" ? \".\" + Z(j, 0) : C, ie(_) ? (h = \"\", n != null && (h = n.replace(we, \"$&/\") + \"/\"), re(_, s, h, \"\", function(U) {\n        return U;\n      })) : _ != null && (Ce(_) && (_ = Re(_, h + (!_.key || j && j.key === _.key ? \"\" : (\"\" + _.key).replace(we, \"$&/\") + \"/\") + n)), s.push(_)), 1;\n    if (j = 0, C = C === \"\" ? \".\" : C + \":\", ie(n))\n      for (var T = 0; T < n.length; T++) {\n        P = n[T];\n        var w = C + Z(P, T);\n        j += re(P, s, h, w, _);\n      }\n    else if (w = X(n), typeof w == \"function\")\n      for (n = w.call(n), T = 0; !(P = n.next()).done; )\n        P = P.value, w = C + Z(P, T++), j += re(P, s, h, w, _);\n    else if (P === \"object\")\n      throw s = String(n), Error(\"Objects are not valid as a React child (found: \" + (s === \"[object Object]\" ? \"object with keys {\" + Object.keys(n).join(\", \") + \"}\" : s) + \"). If you meant to render a collection of children, use an array instead.\");\n    return j;\n  }\n  function B(n, s, h) {\n    if (n == null)\n      return n;\n    var C = [], _ = 0;\n    return re(n, C, \"\", \"\", function(P) {\n      return s.call(h, P, _++);\n    }), C;\n  }\n  function ue(n) {\n    if (n._status === -1) {\n      var s = n._result;\n      s = s(), s.then(function(h) {\n        (n._status === 0 || n._status === -1) && (n._status = 1, n._result = h);\n      }, function(h) {\n        (n._status === 0 || n._status === -1) && (n._status = 2, n._result = h);\n      }), n._status === -1 && (n._status = 0, n._result = s);\n    }\n    if (n._status === 1)\n      return n._result.default;\n    throw n._result;\n  }\n  var d = { current: null }, le = { transition: null }, Se = { ReactCurrentDispatcher: d, ReactCurrentBatchConfig: le, ReactCurrentOwner: Q };\n  return g.Children = { map: B, forEach: function(n, s, h) {\n    B(n, function() {\n      s.apply(this, arguments);\n    }, h);\n  }, count: function(n) {\n    var s = 0;\n    return B(n, function() {\n      s++;\n    }), s;\n  }, toArray: function(n) {\n    return B(n, function(s) {\n      return s;\n    }) || [];\n  }, only: function(n) {\n    if (!Ce(n))\n      throw Error(\"React.Children.only expected to receive a single React element child.\");\n    return n;\n  } }, g.Component = ae, g.Fragment = pe, g.Profiler = ne, g.PureComponent = L, g.StrictMode = G, g.Suspense = D, g.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Se, g.cloneElement = function(n, s, h) {\n    if (n == null)\n      throw Error(\"React.cloneElement(...): The argument must be a React element, but you passed \" + n + \".\");\n    var C = fe({}, n.props), _ = n.key, P = n.ref, j = n._owner;\n    if (s != null) {\n      if (s.ref !== void 0 && (P = s.ref, j = Q.current), s.key !== void 0 && (_ = \"\" + s.key), n.type && n.type.defaultProps)\n        var T = n.type.defaultProps;\n      for (w in s)\n        N.call(s, w) && !ce.hasOwnProperty(w) && (C[w] = s[w] === void 0 && T !== void 0 ? T[w] : s[w]);\n    }\n    var w = arguments.length - 2;\n    if (w === 1)\n      C.children = h;\n    else if (1 < w) {\n      T = Array(w);\n      for (var U = 0; U < w; U++)\n        T[U] = arguments[U + 2];\n      C.children = T;\n    }\n    return { $$typeof: Y, type: n.type, key: _, ref: P, props: C, _owner: j };\n  }, g.createContext = function(n) {\n    return n = { $$typeof: H, _currentValue: n, _currentValue2: n, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, n.Provider = { $$typeof: ee, _context: n }, n.Consumer = n;\n  }, g.createElement = ve, g.createFactory = function(n) {\n    var s = ve.bind(null, n);\n    return s.type = n, s;\n  }, g.createRef = function() {\n    return { current: null };\n  }, g.forwardRef = function(n) {\n    return { $$typeof: K, render: n };\n  }, g.isValidElement = Ce, g.lazy = function(n) {\n    return { $$typeof: I, _payload: { _status: -1, _result: n }, _init: ue };\n  }, g.memo = function(n, s) {\n    return { $$typeof: J, type: n, compare: s === void 0 ? null : s };\n  }, g.startTransition = function(n) {\n    var s = le.transition;\n    le.transition = {};\n    try {\n      n();\n    } finally {\n      le.transition = s;\n    }\n  }, g.unstable_act = function() {\n    throw Error(\"act(...) is not supported in production builds of React.\");\n  }, g.useCallback = function(n, s) {\n    return d.current.useCallback(n, s);\n  }, g.useContext = function(n) {\n    return d.current.useContext(n);\n  }, g.useDebugValue = function() {\n  }, g.useDeferredValue = function(n) {\n    return d.current.useDeferredValue(n);\n  }, g.useEffect = function(n, s) {\n    return d.current.useEffect(n, s);\n  }, g.useId = function() {\n    return d.current.useId();\n  }, g.useImperativeHandle = function(n, s, h) {\n    return d.current.useImperativeHandle(n, s, h);\n  }, g.useInsertionEffect = function(n, s) {\n    return d.current.useInsertionEffect(n, s);\n  }, g.useLayoutEffect = function(n, s) {\n    return d.current.useLayoutEffect(n, s);\n  }, g.useMemo = function(n, s) {\n    return d.current.useMemo(n, s);\n  }, g.useReducer = function(n, s, h) {\n    return d.current.useReducer(n, s, h);\n  }, g.useRef = function(n) {\n    return d.current.useRef(n);\n  }, g.useState = function(n) {\n    return d.current.useState(n);\n  }, g.useSyncExternalStore = function(n, s, h) {\n    return d.current.useSyncExternalStore(n, s, h);\n  }, g.useTransition = function() {\n    return d.current.useTransition();\n  }, g.version = \"18.2.0\", g;\n}\nvar Ke = { exports: {} };\n/**\n * @license React\n * react.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nKe.exports;\nvar ct;\nfunction Mt() {\n  return ct || (ct = 1, function(Y, v) {\n     true && function() {\n      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < \"u\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == \"function\" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n      var pe = \"18.2.0\", G = Symbol.for(\"react.element\"), ne = Symbol.for(\"react.portal\"), ee = Symbol.for(\"react.fragment\"), H = Symbol.for(\"react.strict_mode\"), K = Symbol.for(\"react.profiler\"), D = Symbol.for(\"react.provider\"), J = Symbol.for(\"react.context\"), I = Symbol.for(\"react.forward_ref\"), W = Symbol.for(\"react.suspense\"), X = Symbol.for(\"react.suspense_list\"), k = Symbol.for(\"react.memo\"), fe = Symbol.for(\"react.lazy\"), Ie = Symbol.for(\"react.offscreen\"), ae = Symbol.iterator, oe = \"@@iterator\";\n      function L(e) {\n        if (e === null || typeof e != \"object\")\n          return null;\n        var r = ae && e[ae] || e[oe];\n        return typeof r == \"function\" ? r : null;\n      }\n      var he = {\n        /**\n         * @internal\n         * @type {ReactComponent}\n         */\n        current: null\n      }, ie = {\n        transition: null\n      }, N = {\n        current: null,\n        // Used to reproduce behavior of `batchedUpdates` in legacy mode.\n        isBatchingLegacy: !1,\n        didScheduleLegacyUpdate: !1\n      }, Q = {\n        /**\n         * @internal\n         * @type {ReactComponent}\n         */\n        current: null\n      }, ce = {}, ve = null;\n      function Re(e) {\n        ve = e;\n      }\n      ce.setExtraStackFrame = function(e) {\n        ve = e;\n      }, ce.getCurrentStack = null, ce.getStackAddendum = function() {\n        var e = \"\";\n        ve && (e += ve);\n        var r = ce.getCurrentStack;\n        return r && (e += r() || \"\"), e;\n      };\n      var Ce = !1, Ue = !1, we = !1, Z = !1, re = !1, B = {\n        ReactCurrentDispatcher: he,\n        ReactCurrentBatchConfig: ie,\n        ReactCurrentOwner: Q\n      };\n      B.ReactDebugCurrentFrame = ce, B.ReactCurrentActQueue = N;\n      function ue(e) {\n        {\n          for (var r = arguments.length, a = new Array(r > 1 ? r - 1 : 0), o = 1; o < r; o++)\n            a[o - 1] = arguments[o];\n          le(\"warn\", e, a);\n        }\n      }\n      function d(e) {\n        {\n          for (var r = arguments.length, a = new Array(r > 1 ? r - 1 : 0), o = 1; o < r; o++)\n            a[o - 1] = arguments[o];\n          le(\"error\", e, a);\n        }\n      }\n      function le(e, r, a) {\n        {\n          var o = B.ReactDebugCurrentFrame, u = o.getStackAddendum();\n          u !== \"\" && (r += \"%s\", a = a.concat([u]));\n          var p = a.map(function(l) {\n            return String(l);\n          });\n          p.unshift(\"Warning: \" + r), Function.prototype.apply.call(console[e], console, p);\n        }\n      }\n      var Se = {};\n      function n(e, r) {\n        {\n          var a = e.constructor, o = a && (a.displayName || a.name) || \"ReactClass\", u = o + \".\" + r;\n          if (Se[u])\n            return;\n          d(\"Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.\", r, o), Se[u] = !0;\n        }\n      }\n      var s = {\n        /**\n         * Checks whether or not this composite component is mounted.\n         * @param {ReactClass} publicInstance The instance we want to test.\n         * @return {boolean} True if mounted, false otherwise.\n         * @protected\n         * @final\n         */\n        isMounted: function(e) {\n          return !1;\n        },\n        /**\n         * Forces an update. This should only be invoked when it is known with\n         * certainty that we are **not** in a DOM transaction.\n         *\n         * You may want to call this when you know that some deeper aspect of the\n         * component's state has changed but `setState` was not called.\n         *\n         * This will not invoke `shouldComponentUpdate`, but it will invoke\n         * `componentWillUpdate` and `componentDidUpdate`.\n         *\n         * @param {ReactClass} publicInstance The instance that should rerender.\n         * @param {?function} callback Called after component is updated.\n         * @param {?string} callerName name of the calling function in the public API.\n         * @internal\n         */\n        enqueueForceUpdate: function(e, r, a) {\n          n(e, \"forceUpdate\");\n        },\n        /**\n         * Replaces all of the state. Always use this or `setState` to mutate state.\n         * You should treat `this.state` as immutable.\n         *\n         * There is no guarantee that `this.state` will be immediately updated, so\n         * accessing `this.state` after calling this method may return the old value.\n         *\n         * @param {ReactClass} publicInstance The instance that should rerender.\n         * @param {object} completeState Next state.\n         * @param {?function} callback Called after component is updated.\n         * @param {?string} callerName name of the calling function in the public API.\n         * @internal\n         */\n        enqueueReplaceState: function(e, r, a, o) {\n          n(e, \"replaceState\");\n        },\n        /**\n         * Sets a subset of the state. This only exists because _pendingState is\n         * internal. This provides a merging strategy that is not available to deep\n         * properties which is confusing. TODO: Expose pendingState or don't use it\n         * during the merge.\n         *\n         * @param {ReactClass} publicInstance The instance that should rerender.\n         * @param {object} partialState Next partial state to be merged with state.\n         * @param {?function} callback Called after component is updated.\n         * @param {?string} Name of the calling function in the public API.\n         * @internal\n         */\n        enqueueSetState: function(e, r, a, o) {\n          n(e, \"setState\");\n        }\n      }, h = Object.assign, C = {};\n      Object.freeze(C);\n      function _(e, r, a) {\n        this.props = e, this.context = r, this.refs = C, this.updater = a || s;\n      }\n      _.prototype.isReactComponent = {}, _.prototype.setState = function(e, r) {\n        if (typeof e != \"object\" && typeof e != \"function\" && e != null)\n          throw new Error(\"setState(...): takes an object of state variables to update or a function which returns an object of state variables.\");\n        this.updater.enqueueSetState(this, e, r, \"setState\");\n      }, _.prototype.forceUpdate = function(e) {\n        this.updater.enqueueForceUpdate(this, e, \"forceUpdate\");\n      };\n      {\n        var P = {\n          isMounted: [\"isMounted\", \"Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks.\"],\n          replaceState: [\"replaceState\", \"Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236).\"]\n        }, j = function(e, r) {\n          Object.defineProperty(_.prototype, e, {\n            get: function() {\n              ue(\"%s(...) is deprecated in plain JavaScript React classes. %s\", r[0], r[1]);\n            }\n          });\n        };\n        for (var T in P)\n          P.hasOwnProperty(T) && j(T, P[T]);\n      }\n      function w() {\n      }\n      w.prototype = _.prototype;\n      function U(e, r, a) {\n        this.props = e, this.context = r, this.refs = C, this.updater = a || s;\n      }\n      var me = U.prototype = new w();\n      me.constructor = U, h(me, _.prototype), me.isPureReactComponent = !0;\n      function yr() {\n        var e = {\n          current: null\n        };\n        return Object.seal(e), e;\n      }\n      var Je = Array.isArray;\n      function Fe(e) {\n        return Je(e);\n      }\n      function hr(e) {\n        {\n          var r = typeof Symbol == \"function\" && Symbol.toStringTag, a = r && e[Symbol.toStringTag] || e.constructor.name || \"Object\";\n          return a;\n        }\n      }\n      function $e(e) {\n        try {\n          return Te(e), !1;\n        } catch {\n          return !0;\n        }\n      }\n      function Te(e) {\n        return \"\" + e;\n      }\n      function Oe(e) {\n        if ($e(e))\n          return d(\"The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.\", hr(e)), Te(e);\n      }\n      function Xe(e, r, a) {\n        var o = e.displayName;\n        if (o)\n          return o;\n        var u = r.displayName || r.name || \"\";\n        return u !== \"\" ? a + \"(\" + u + \")\" : a;\n      }\n      function Pe(e) {\n        return e.displayName || \"Context\";\n      }\n      function de(e) {\n        if (e == null)\n          return null;\n        if (typeof e.tag == \"number\" && d(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"), typeof e == \"function\")\n          return e.displayName || e.name || null;\n        if (typeof e == \"string\")\n          return e;\n        switch (e) {\n          case ee:\n            return \"Fragment\";\n          case ne:\n            return \"Portal\";\n          case K:\n            return \"Profiler\";\n          case H:\n            return \"StrictMode\";\n          case W:\n            return \"Suspense\";\n          case X:\n            return \"SuspenseList\";\n        }\n        if (typeof e == \"object\")\n          switch (e.$$typeof) {\n            case J:\n              var r = e;\n              return Pe(r) + \".Consumer\";\n            case D:\n              var a = e;\n              return Pe(a._context) + \".Provider\";\n            case I:\n              return Xe(e, e.render, \"ForwardRef\");\n            case k:\n              var o = e.displayName || null;\n              return o !== null ? o : de(e.type) || \"Memo\";\n            case fe: {\n              var u = e, p = u._payload, l = u._init;\n              try {\n                return de(l(p));\n              } catch {\n                return null;\n              }\n            }\n          }\n        return null;\n      }\n      var ke = Object.prototype.hasOwnProperty, Le = {\n        key: !0,\n        ref: !0,\n        __self: !0,\n        __source: !0\n      }, Qe, Ze, Ve;\n      Ve = {};\n      function Ye(e) {\n        if (ke.call(e, \"ref\")) {\n          var r = Object.getOwnPropertyDescriptor(e, \"ref\").get;\n          if (r && r.isReactWarning)\n            return !1;\n        }\n        return e.ref !== void 0;\n      }\n      function ge(e) {\n        if (ke.call(e, \"key\")) {\n          var r = Object.getOwnPropertyDescriptor(e, \"key\").get;\n          if (r && r.isReactWarning)\n            return !1;\n        }\n        return e.key !== void 0;\n      }\n      function mr(e, r) {\n        var a = function() {\n          Qe || (Qe = !0, d(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", r));\n        };\n        a.isReactWarning = !0, Object.defineProperty(e, \"key\", {\n          get: a,\n          configurable: !0\n        });\n      }\n      function er(e, r) {\n        var a = function() {\n          Ze || (Ze = !0, d(\"%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", r));\n        };\n        a.isReactWarning = !0, Object.defineProperty(e, \"ref\", {\n          get: a,\n          configurable: !0\n        });\n      }\n      function rr(e) {\n        if (typeof e.ref == \"string\" && Q.current && e.__self && Q.current.stateNode !== e.__self) {\n          var r = de(Q.current.type);\n          Ve[r] || (d('Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', r, e.ref), Ve[r] = !0);\n        }\n      }\n      var je = function(e, r, a, o, u, p, l) {\n        var y = {\n          // This tag allows us to uniquely identify this as a React Element\n          $$typeof: G,\n          // Built-in properties that belong on the element\n          type: e,\n          key: r,\n          ref: a,\n          props: l,\n          // Record the component responsible for creating this element.\n          _owner: p\n        };\n        return y._store = {}, Object.defineProperty(y._store, \"validated\", {\n          configurable: !1,\n          enumerable: !1,\n          writable: !0,\n          value: !1\n        }), Object.defineProperty(y, \"_self\", {\n          configurable: !1,\n          enumerable: !1,\n          writable: !1,\n          value: o\n        }), Object.defineProperty(y, \"_source\", {\n          configurable: !1,\n          enumerable: !1,\n          writable: !1,\n          value: u\n        }), Object.freeze && (Object.freeze(y.props), Object.freeze(y)), y;\n      };\n      function gr(e, r, a) {\n        var o, u = {}, p = null, l = null, y = null, E = null;\n        if (r != null) {\n          Ye(r) && (l = r.ref, rr(r)), ge(r) && (Oe(r.key), p = \"\" + r.key), y = r.__self === void 0 ? null : r.__self, E = r.__source === void 0 ? null : r.__source;\n          for (o in r)\n            ke.call(r, o) && !Le.hasOwnProperty(o) && (u[o] = r[o]);\n        }\n        var O = arguments.length - 2;\n        if (O === 1)\n          u.children = a;\n        else if (O > 1) {\n          for (var A = Array(O), x = 0; x < O; x++)\n            A[x] = arguments[x + 2];\n          Object.freeze && Object.freeze(A), u.children = A;\n        }\n        if (e && e.defaultProps) {\n          var $ = e.defaultProps;\n          for (o in $)\n            u[o] === void 0 && (u[o] = $[o]);\n        }\n        if (p || l) {\n          var M = typeof e == \"function\" ? e.displayName || e.name || \"Unknown\" : e;\n          p && mr(u, M), l && er(u, M);\n        }\n        return je(e, p, l, y, E, Q.current, u);\n      }\n      function _r(e, r) {\n        var a = je(e.type, r, e.ref, e._self, e._source, e._owner, e.props);\n        return a;\n      }\n      function br(e, r, a) {\n        if (e == null)\n          throw new Error(\"React.cloneElement(...): The argument must be a React element, but you passed \" + e + \".\");\n        var o, u = h({}, e.props), p = e.key, l = e.ref, y = e._self, E = e._source, O = e._owner;\n        if (r != null) {\n          Ye(r) && (l = r.ref, O = Q.current), ge(r) && (Oe(r.key), p = \"\" + r.key);\n          var A;\n          e.type && e.type.defaultProps && (A = e.type.defaultProps);\n          for (o in r)\n            ke.call(r, o) && !Le.hasOwnProperty(o) && (r[o] === void 0 && A !== void 0 ? u[o] = A[o] : u[o] = r[o]);\n        }\n        var x = arguments.length - 2;\n        if (x === 1)\n          u.children = a;\n        else if (x > 1) {\n          for (var $ = Array(x), M = 0; M < x; M++)\n            $[M] = arguments[M + 2];\n          u.children = $;\n        }\n        return je(e.type, p, l, y, E, O, u);\n      }\n      function _e(e) {\n        return typeof e == \"object\" && e !== null && e.$$typeof === G;\n      }\n      var tr = \".\", Er = \":\";\n      function Rr(e) {\n        var r = /[=:]/g, a = {\n          \"=\": \"=0\",\n          \":\": \"=2\"\n        }, o = e.replace(r, function(u) {\n          return a[u];\n        });\n        return \"$\" + o;\n      }\n      var Ne = !1, nr = /\\/+/g;\n      function ye(e) {\n        return e.replace(nr, \"$&/\");\n      }\n      function Ae(e, r) {\n        return typeof e == \"object\" && e !== null && e.key != null ? (Oe(e.key), Rr(\"\" + e.key)) : r.toString(36);\n      }\n      function be(e, r, a, o, u) {\n        var p = typeof e;\n        (p === \"undefined\" || p === \"boolean\") && (e = null);\n        var l = !1;\n        if (e === null)\n          l = !0;\n        else\n          switch (p) {\n            case \"string\":\n            case \"number\":\n              l = !0;\n              break;\n            case \"object\":\n              switch (e.$$typeof) {\n                case G:\n                case ne:\n                  l = !0;\n              }\n          }\n        if (l) {\n          var y = e, E = u(y), O = o === \"\" ? tr + Ae(y, 0) : o;\n          if (Fe(E)) {\n            var A = \"\";\n            O != null && (A = ye(O) + \"/\"), be(E, r, A, \"\", function(Vt) {\n              return Vt;\n            });\n          } else\n            E != null && (_e(E) && (E.key && (!y || y.key !== E.key) && Oe(E.key), E = _r(\n              E,\n              // Keep both the (mapped) and old keys if they differ, just as\n              // traverseAllChildren used to do for objects as children\n              a + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key\n              (E.key && (!y || y.key !== E.key) ? (\n                // $FlowFixMe Flow incorrectly thinks existing element's key can be a number\n                // eslint-disable-next-line react-internal/safe-string-coercion\n                ye(\"\" + E.key) + \"/\"\n              ) : \"\") + O\n            )), r.push(E));\n          return 1;\n        }\n        var x, $, M = 0, q = o === \"\" ? tr : o + Er;\n        if (Fe(e))\n          for (var vr = 0; vr < e.length; vr++)\n            x = e[vr], $ = q + Ae(x, vr), M += be(x, r, a, $, u);\n        else {\n          var $r = L(e);\n          if (typeof $r == \"function\") {\n            var it = e;\n            $r === it.entries && (Ne || ue(\"Using Maps as children is not supported. Use an array of keyed ReactElements instead.\"), Ne = !0);\n            for (var $t = $r.call(it), ut, Lt = 0; !(ut = $t.next()).done; )\n              x = ut.value, $ = q + Ae(x, Lt++), M += be(x, r, a, $, u);\n          } else if (p === \"object\") {\n            var st = String(e);\n            throw new Error(\"Objects are not valid as a React child (found: \" + (st === \"[object Object]\" ? \"object with keys {\" + Object.keys(e).join(\", \") + \"}\" : st) + \"). If you meant to render a collection of children, use an array instead.\");\n          }\n        }\n        return M;\n      }\n      function xe(e, r, a) {\n        if (e == null)\n          return e;\n        var o = [], u = 0;\n        return be(e, o, \"\", \"\", function(p) {\n          return r.call(a, p, u++);\n        }), o;\n      }\n      function Cr(e) {\n        var r = 0;\n        return xe(e, function() {\n          r++;\n        }), r;\n      }\n      function ar(e, r, a) {\n        xe(e, function() {\n          r.apply(this, arguments);\n        }, a);\n      }\n      function wr(e) {\n        return xe(e, function(r) {\n          return r;\n        }) || [];\n      }\n      function or(e) {\n        if (!_e(e))\n          throw new Error(\"React.Children.only expected to receive a single React element child.\");\n        return e;\n      }\n      function ir(e) {\n        var r = {\n          $$typeof: J,\n          // As a workaround to support multiple concurrent renderers, we categorize\n          // some renderers as primary and others as secondary. We only expect\n          // there to be two concurrent renderers at most: React Native (primary) and\n          // Fabric (secondary); React DOM (primary) and React ART (secondary).\n          // Secondary renderers store their context values on separate fields.\n          _currentValue: e,\n          _currentValue2: e,\n          // Used to track how many concurrent renderers this context currently\n          // supports within in a single renderer. Such as parallel server rendering.\n          _threadCount: 0,\n          // These are circular\n          Provider: null,\n          Consumer: null,\n          // Add these to use same hidden class in VM as ServerContext\n          _defaultValue: null,\n          _globalName: null\n        };\n        r.Provider = {\n          $$typeof: D,\n          _context: r\n        };\n        var a = !1, o = !1, u = !1;\n        {\n          var p = {\n            $$typeof: J,\n            _context: r\n          };\n          Object.defineProperties(p, {\n            Provider: {\n              get: function() {\n                return o || (o = !0, d(\"Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?\")), r.Provider;\n              },\n              set: function(l) {\n                r.Provider = l;\n              }\n            },\n            _currentValue: {\n              get: function() {\n                return r._currentValue;\n              },\n              set: function(l) {\n                r._currentValue = l;\n              }\n            },\n            _currentValue2: {\n              get: function() {\n                return r._currentValue2;\n              },\n              set: function(l) {\n                r._currentValue2 = l;\n              }\n            },\n            _threadCount: {\n              get: function() {\n                return r._threadCount;\n              },\n              set: function(l) {\n                r._threadCount = l;\n              }\n            },\n            Consumer: {\n              get: function() {\n                return a || (a = !0, d(\"Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?\")), r.Consumer;\n              }\n            },\n            displayName: {\n              get: function() {\n                return r.displayName;\n              },\n              set: function(l) {\n                u || (ue(\"Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.\", l), u = !0);\n              }\n            }\n          }), r.Consumer = p;\n        }\n        return r._currentRenderer = null, r._currentRenderer2 = null, r;\n      }\n      var De = -1, Be = 0, ze = 1, Sr = 2;\n      function Tr(e) {\n        if (e._status === De) {\n          var r = e._result, a = r();\n          if (a.then(function(p) {\n            if (e._status === Be || e._status === De) {\n              var l = e;\n              l._status = ze, l._result = p;\n            }\n          }, function(p) {\n            if (e._status === Be || e._status === De) {\n              var l = e;\n              l._status = Sr, l._result = p;\n            }\n          }), e._status === De) {\n            var o = e;\n            o._status = Be, o._result = a;\n          }\n        }\n        if (e._status === ze) {\n          var u = e._result;\n          return u === void 0 && d(`lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?`, u), \"default\" in u || d(`lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))`, u), u.default;\n        } else\n          throw e._result;\n      }\n      function Or(e) {\n        var r = {\n          // We use these fields to store the result.\n          _status: De,\n          _result: e\n        }, a = {\n          $$typeof: fe,\n          _payload: r,\n          _init: Tr\n        };\n        {\n          var o, u;\n          Object.defineProperties(a, {\n            defaultProps: {\n              configurable: !0,\n              get: function() {\n                return o;\n              },\n              set: function(p) {\n                d(\"React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.\"), o = p, Object.defineProperty(a, \"defaultProps\", {\n                  enumerable: !0\n                });\n              }\n            },\n            propTypes: {\n              configurable: !0,\n              get: function() {\n                return u;\n              },\n              set: function(p) {\n                d(\"React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.\"), u = p, Object.defineProperty(a, \"propTypes\", {\n                  enumerable: !0\n                });\n              }\n            }\n          });\n        }\n        return a;\n      }\n      function Pr(e) {\n        e != null && e.$$typeof === k ? d(\"forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).\") : typeof e != \"function\" ? d(\"forwardRef requires a render function but was given %s.\", e === null ? \"null\" : typeof e) : e.length !== 0 && e.length !== 2 && d(\"forwardRef render functions accept exactly two parameters: props and ref. %s\", e.length === 1 ? \"Did you forget to use the ref parameter?\" : \"Any additional parameter will be undefined.\"), e != null && (e.defaultProps != null || e.propTypes != null) && d(\"forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?\");\n        var r = {\n          $$typeof: I,\n          render: e\n        };\n        {\n          var a;\n          Object.defineProperty(r, \"displayName\", {\n            enumerable: !1,\n            configurable: !0,\n            get: function() {\n              return a;\n            },\n            set: function(o) {\n              a = o, !e.name && !e.displayName && (e.displayName = o);\n            }\n          });\n        }\n        return r;\n      }\n      var t;\n      t = Symbol.for(\"react.module.reference\");\n      function i(e) {\n        return !!(typeof e == \"string\" || typeof e == \"function\" || e === ee || e === K || re || e === H || e === W || e === X || Z || e === Ie || Ce || Ue || we || typeof e == \"object\" && e !== null && (e.$$typeof === fe || e.$$typeof === k || e.$$typeof === D || e.$$typeof === J || e.$$typeof === I || // This needs to include all possible module reference object\n        // types supported by any Flight configuration anywhere since\n        // we don't know which Flight build this will end up being used\n        // with.\n        e.$$typeof === t || e.getModuleId !== void 0));\n      }\n      function f(e, r) {\n        i(e) || d(\"memo: The first argument must be a component. Instead received: %s\", e === null ? \"null\" : typeof e);\n        var a = {\n          $$typeof: k,\n          type: e,\n          compare: r === void 0 ? null : r\n        };\n        {\n          var o;\n          Object.defineProperty(a, \"displayName\", {\n            enumerable: !1,\n            configurable: !0,\n            get: function() {\n              return o;\n            },\n            set: function(u) {\n              o = u, !e.name && !e.displayName && (e.displayName = u);\n            }\n          });\n        }\n        return a;\n      }\n      function c() {\n        var e = he.current;\n        return e === null && d(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`), e;\n      }\n      function R(e) {\n        var r = c();\n        if (e._context !== void 0) {\n          var a = e._context;\n          a.Consumer === e ? d(\"Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?\") : a.Provider === e && d(\"Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?\");\n        }\n        return r.useContext(e);\n      }\n      function S(e) {\n        var r = c();\n        return r.useState(e);\n      }\n      function b(e, r, a) {\n        var o = c();\n        return o.useReducer(e, r, a);\n      }\n      function m(e) {\n        var r = c();\n        return r.useRef(e);\n      }\n      function z(e, r) {\n        var a = c();\n        return a.useEffect(e, r);\n      }\n      function F(e, r) {\n        var a = c();\n        return a.useInsertionEffect(e, r);\n      }\n      function V(e, r) {\n        var a = c();\n        return a.useLayoutEffect(e, r);\n      }\n      function te(e, r) {\n        var a = c();\n        return a.useCallback(e, r);\n      }\n      function Ee(e, r) {\n        var a = c();\n        return a.useMemo(e, r);\n      }\n      function ur(e, r, a) {\n        var o = c();\n        return o.useImperativeHandle(e, r, a);\n      }\n      function se(e, r) {\n        {\n          var a = c();\n          return a.useDebugValue(e, r);\n        }\n      }\n      function pt() {\n        var e = c();\n        return e.useTransition();\n      }\n      function vt(e) {\n        var r = c();\n        return r.useDeferredValue(e);\n      }\n      function yt() {\n        var e = c();\n        return e.useId();\n      }\n      function ht(e, r, a) {\n        var o = c();\n        return o.useSyncExternalStore(e, r, a);\n      }\n      var qe = 0, Mr, Wr, Ur, Yr, Br, zr, qr;\n      function Gr() {\n      }\n      Gr.__reactDisabledLog = !0;\n      function mt() {\n        {\n          if (qe === 0) {\n            Mr = console.log, Wr = console.info, Ur = console.warn, Yr = console.error, Br = console.group, zr = console.groupCollapsed, qr = console.groupEnd;\n            var e = {\n              configurable: !0,\n              enumerable: !0,\n              value: Gr,\n              writable: !0\n            };\n            Object.defineProperties(console, {\n              info: e,\n              log: e,\n              warn: e,\n              error: e,\n              group: e,\n              groupCollapsed: e,\n              groupEnd: e\n            });\n          }\n          qe++;\n        }\n      }\n      function gt() {\n        {\n          if (qe--, qe === 0) {\n            var e = {\n              configurable: !0,\n              enumerable: !0,\n              writable: !0\n            };\n            Object.defineProperties(console, {\n              log: h({}, e, {\n                value: Mr\n              }),\n              info: h({}, e, {\n                value: Wr\n              }),\n              warn: h({}, e, {\n                value: Ur\n              }),\n              error: h({}, e, {\n                value: Yr\n              }),\n              group: h({}, e, {\n                value: Br\n              }),\n              groupCollapsed: h({}, e, {\n                value: zr\n              }),\n              groupEnd: h({}, e, {\n                value: qr\n              })\n            });\n          }\n          qe < 0 && d(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n        }\n      }\n      var kr = B.ReactCurrentDispatcher, jr;\n      function sr(e, r, a) {\n        {\n          if (jr === void 0)\n            try {\n              throw Error();\n            } catch (u) {\n              var o = u.stack.trim().match(/\\n( *(at )?)/);\n              jr = o && o[1] || \"\";\n            }\n          return `\n` + jr + e;\n        }\n      }\n      var Ar = !1, fr;\n      {\n        var _t = typeof WeakMap == \"function\" ? WeakMap : Map;\n        fr = new _t();\n      }\n      function Hr(e, r) {\n        if (!e || Ar)\n          return \"\";\n        {\n          var a = fr.get(e);\n          if (a !== void 0)\n            return a;\n        }\n        var o;\n        Ar = !0;\n        var u = Error.prepareStackTrace;\n        Error.prepareStackTrace = void 0;\n        var p;\n        p = kr.current, kr.current = null, mt();\n        try {\n          if (r) {\n            var l = function() {\n              throw Error();\n            };\n            if (Object.defineProperty(l.prototype, \"props\", {\n              set: function() {\n                throw Error();\n              }\n            }), typeof Reflect == \"object\" && Reflect.construct) {\n              try {\n                Reflect.construct(l, []);\n              } catch (q) {\n                o = q;\n              }\n              Reflect.construct(e, [], l);\n            } else {\n              try {\n                l.call();\n              } catch (q) {\n                o = q;\n              }\n              e.call(l.prototype);\n            }\n          } else {\n            try {\n              throw Error();\n            } catch (q) {\n              o = q;\n            }\n            e();\n          }\n        } catch (q) {\n          if (q && o && typeof q.stack == \"string\") {\n            for (var y = q.stack.split(`\n`), E = o.stack.split(`\n`), O = y.length - 1, A = E.length - 1; O >= 1 && A >= 0 && y[O] !== E[A]; )\n              A--;\n            for (; O >= 1 && A >= 0; O--, A--)\n              if (y[O] !== E[A]) {\n                if (O !== 1 || A !== 1)\n                  do\n                    if (O--, A--, A < 0 || y[O] !== E[A]) {\n                      var x = `\n` + y[O].replace(\" at new \", \" at \");\n                      return e.displayName && x.includes(\"<anonymous>\") && (x = x.replace(\"<anonymous>\", e.displayName)), typeof e == \"function\" && fr.set(e, x), x;\n                    }\n                  while (O >= 1 && A >= 0);\n                break;\n              }\n          }\n        } finally {\n          Ar = !1, kr.current = p, gt(), Error.prepareStackTrace = u;\n        }\n        var $ = e ? e.displayName || e.name : \"\", M = $ ? sr($) : \"\";\n        return typeof e == \"function\" && fr.set(e, M), M;\n      }\n      function bt(e, r, a) {\n        return Hr(e, !1);\n      }\n      function Et(e) {\n        var r = e.prototype;\n        return !!(r && r.isReactComponent);\n      }\n      function cr(e, r, a) {\n        if (e == null)\n          return \"\";\n        if (typeof e == \"function\")\n          return Hr(e, Et(e));\n        if (typeof e == \"string\")\n          return sr(e);\n        switch (e) {\n          case W:\n            return sr(\"Suspense\");\n          case X:\n            return sr(\"SuspenseList\");\n        }\n        if (typeof e == \"object\")\n          switch (e.$$typeof) {\n            case I:\n              return bt(e.render);\n            case k:\n              return cr(e.type, r, a);\n            case fe: {\n              var o = e, u = o._payload, p = o._init;\n              try {\n                return cr(p(u), r, a);\n              } catch {\n              }\n            }\n          }\n        return \"\";\n      }\n      var Kr = {}, Jr = B.ReactDebugCurrentFrame;\n      function lr(e) {\n        if (e) {\n          var r = e._owner, a = cr(e.type, e._source, r ? r.type : null);\n          Jr.setExtraStackFrame(a);\n        } else\n          Jr.setExtraStackFrame(null);\n      }\n      function Rt(e, r, a, o, u) {\n        {\n          var p = Function.call.bind(ke);\n          for (var l in e)\n            if (p(e, l)) {\n              var y = void 0;\n              try {\n                if (typeof e[l] != \"function\") {\n                  var E = Error((o || \"React class\") + \": \" + a + \" type `\" + l + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof e[l] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                  throw E.name = \"Invariant Violation\", E;\n                }\n                y = e[l](r, l, o, a, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n              } catch (O) {\n                y = O;\n              }\n              y && !(y instanceof Error) && (lr(u), d(\"%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\", o || \"React class\", a, l, typeof y), lr(null)), y instanceof Error && !(y.message in Kr) && (Kr[y.message] = !0, lr(u), d(\"Failed %s type: %s\", a, y.message), lr(null));\n            }\n        }\n      }\n      function Me(e) {\n        if (e) {\n          var r = e._owner, a = cr(e.type, e._source, r ? r.type : null);\n          Re(a);\n        } else\n          Re(null);\n      }\n      var xr;\n      xr = !1;\n      function Xr() {\n        if (Q.current) {\n          var e = de(Q.current.type);\n          if (e)\n            return `\n\nCheck the render method of \\`` + e + \"`.\";\n        }\n        return \"\";\n      }\n      function Ct(e) {\n        if (e !== void 0) {\n          var r = e.fileName.replace(/^.*[\\\\\\/]/, \"\"), a = e.lineNumber;\n          return `\n\nCheck your code at ` + r + \":\" + a + \".\";\n        }\n        return \"\";\n      }\n      function wt(e) {\n        return e != null ? Ct(e.__source) : \"\";\n      }\n      var Qr = {};\n      function St(e) {\n        var r = Xr();\n        if (!r) {\n          var a = typeof e == \"string\" ? e : e.displayName || e.name;\n          a && (r = `\n\nCheck the top-level render call using <` + a + \">.\");\n        }\n        return r;\n      }\n      function Zr(e, r) {\n        if (!(!e._store || e._store.validated || e.key != null)) {\n          e._store.validated = !0;\n          var a = St(r);\n          if (!Qr[a]) {\n            Qr[a] = !0;\n            var o = \"\";\n            e && e._owner && e._owner !== Q.current && (o = \" It was passed a child from \" + de(e._owner.type) + \".\"), Me(e), d('Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', a, o), Me(null);\n          }\n        }\n      }\n      function et(e, r) {\n        if (typeof e == \"object\") {\n          if (Fe(e))\n            for (var a = 0; a < e.length; a++) {\n              var o = e[a];\n              _e(o) && Zr(o, r);\n            }\n          else if (_e(e))\n            e._store && (e._store.validated = !0);\n          else if (e) {\n            var u = L(e);\n            if (typeof u == \"function\" && u !== e.entries)\n              for (var p = u.call(e), l; !(l = p.next()).done; )\n                _e(l.value) && Zr(l.value, r);\n          }\n        }\n      }\n      function rt(e) {\n        {\n          var r = e.type;\n          if (r == null || typeof r == \"string\")\n            return;\n          var a;\n          if (typeof r == \"function\")\n            a = r.propTypes;\n          else if (typeof r == \"object\" && (r.$$typeof === I || // Note: Memo only checks outer props here.\n          // Inner props are checked in the reconciler.\n          r.$$typeof === k))\n            a = r.propTypes;\n          else\n            return;\n          if (a) {\n            var o = de(r);\n            Rt(a, e.props, \"prop\", o, e);\n          } else if (r.PropTypes !== void 0 && !xr) {\n            xr = !0;\n            var u = de(r);\n            d(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", u || \"Unknown\");\n          }\n          typeof r.getDefaultProps == \"function\" && !r.getDefaultProps.isReactClassApproved && d(\"getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.\");\n        }\n      }\n      function Tt(e) {\n        {\n          for (var r = Object.keys(e.props), a = 0; a < r.length; a++) {\n            var o = r[a];\n            if (o !== \"children\" && o !== \"key\") {\n              Me(e), d(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", o), Me(null);\n              break;\n            }\n          }\n          e.ref !== null && (Me(e), d(\"Invalid attribute `ref` supplied to `React.Fragment`.\"), Me(null));\n        }\n      }\n      function tt(e, r, a) {\n        var o = i(e);\n        if (!o) {\n          var u = \"\";\n          (e === void 0 || typeof e == \"object\" && e !== null && Object.keys(e).length === 0) && (u += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\");\n          var p = wt(r);\n          p ? u += p : u += Xr();\n          var l;\n          e === null ? l = \"null\" : Fe(e) ? l = \"array\" : e !== void 0 && e.$$typeof === G ? (l = \"<\" + (de(e.type) || \"Unknown\") + \" />\", u = \" Did you accidentally export a JSX literal instead of a component?\") : l = typeof e, d(\"React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\", l, u);\n        }\n        var y = gr.apply(this, arguments);\n        if (y == null)\n          return y;\n        if (o)\n          for (var E = 2; E < arguments.length; E++)\n            et(arguments[E], e);\n        return e === ee ? Tt(y) : rt(y), y;\n      }\n      var nt = !1;\n      function Ot(e) {\n        var r = tt.bind(null, e);\n        return r.type = e, nt || (nt = !0, ue(\"React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.\")), Object.defineProperty(r, \"type\", {\n          enumerable: !1,\n          get: function() {\n            return ue(\"Factory.type is deprecated. Access the class directly before passing it to createFactory.\"), Object.defineProperty(this, \"type\", {\n              value: e\n            }), e;\n          }\n        }), r;\n      }\n      function Pt(e, r, a) {\n        for (var o = br.apply(this, arguments), u = 2; u < arguments.length; u++)\n          et(arguments[u], o.type);\n        return rt(o), o;\n      }\n      function kt(e, r) {\n        var a = ie.transition;\n        ie.transition = {};\n        var o = ie.transition;\n        ie.transition._updatedFibers = /* @__PURE__ */ new Set();\n        try {\n          e();\n        } finally {\n          if (ie.transition = a, a === null && o._updatedFibers) {\n            var u = o._updatedFibers.size;\n            u > 10 && ue(\"Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.\"), o._updatedFibers.clear();\n          }\n        }\n      }\n      var at = !1, dr = null;\n      function jt(e) {\n        if (dr === null)\n          try {\n            var r = (\"require\" + Math.random()).slice(0, 7), a = Y && Y[r];\n            dr = a.call(Y, \"timers\").setImmediate;\n          } catch {\n            dr = function(u) {\n              at === !1 && (at = !0, typeof MessageChannel > \"u\" && d(\"This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.\"));\n              var p = new MessageChannel();\n              p.port1.onmessage = u, p.port2.postMessage(void 0);\n            };\n          }\n        return dr(e);\n      }\n      var We = 0, ot = !1;\n      function At(e) {\n        {\n          var r = We;\n          We++, N.current === null && (N.current = []);\n          var a = N.isBatchingLegacy, o;\n          try {\n            if (N.isBatchingLegacy = !0, o = e(), !a && N.didScheduleLegacyUpdate) {\n              var u = N.current;\n              u !== null && (N.didScheduleLegacyUpdate = !1, Fr(u));\n            }\n          } catch ($) {\n            throw pr(r), $;\n          } finally {\n            N.isBatchingLegacy = a;\n          }\n          if (o !== null && typeof o == \"object\" && typeof o.then == \"function\") {\n            var p = o, l = !1, y = {\n              then: function($, M) {\n                l = !0, p.then(function(q) {\n                  pr(r), We === 0 ? Dr(q, $, M) : $(q);\n                }, function(q) {\n                  pr(r), M(q);\n                });\n              }\n            };\n            return !ot && typeof Promise < \"u\" && Promise.resolve().then(function() {\n            }).then(function() {\n              l || (ot = !0, d(\"You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);\"));\n            }), y;\n          } else {\n            var E = o;\n            if (pr(r), We === 0) {\n              var O = N.current;\n              O !== null && (Fr(O), N.current = null);\n              var A = {\n                then: function($, M) {\n                  N.current === null ? (N.current = [], Dr(E, $, M)) : $(E);\n                }\n              };\n              return A;\n            } else {\n              var x = {\n                then: function($, M) {\n                  $(E);\n                }\n              };\n              return x;\n            }\n          }\n        }\n      }\n      function pr(e) {\n        e !== We - 1 && d(\"You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. \"), We = e;\n      }\n      function Dr(e, r, a) {\n        {\n          var o = N.current;\n          if (o !== null)\n            try {\n              Fr(o), jt(function() {\n                o.length === 0 ? (N.current = null, r(e)) : Dr(e, r, a);\n              });\n            } catch (u) {\n              a(u);\n            }\n          else\n            r(e);\n        }\n      }\n      var Ir = !1;\n      function Fr(e) {\n        if (!Ir) {\n          Ir = !0;\n          var r = 0;\n          try {\n            for (; r < e.length; r++) {\n              var a = e[r];\n              do\n                a = a(!0);\n              while (a !== null);\n            }\n            e.length = 0;\n          } catch (o) {\n            throw e = e.slice(r + 1), o;\n          } finally {\n            Ir = !1;\n          }\n        }\n      }\n      var xt = tt, Dt = Pt, It = Ot, Ft = {\n        map: xe,\n        forEach: ar,\n        count: Cr,\n        toArray: wr,\n        only: or\n      };\n      v.Children = Ft, v.Component = _, v.Fragment = ee, v.Profiler = K, v.PureComponent = U, v.StrictMode = H, v.Suspense = W, v.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = B, v.cloneElement = Dt, v.createContext = ir, v.createElement = xt, v.createFactory = It, v.createRef = yr, v.forwardRef = Pr, v.isValidElement = _e, v.lazy = Or, v.memo = f, v.startTransition = kt, v.unstable_act = At, v.useCallback = te, v.useContext = R, v.useDebugValue = se, v.useDeferredValue = vt, v.useEffect = z, v.useId = yt, v.useImperativeHandle = ur, v.useInsertionEffect = F, v.useLayoutEffect = V, v.useMemo = Ee, v.useReducer = b, v.useRef = m, v.useState = S, v.useSyncExternalStore = ht, v.useTransition = pt, v.version = pe, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < \"u\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == \"function\" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n    }();\n  }(Ke, Ke.exports)), Ke.exports;\n}\n false ? 0 : Vr.exports = Mt();\nvar Nr = Vr.exports;\n/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar lt;\nfunction Wt() {\n  if (lt)\n    return Ge;\n  lt = 1;\n  var Y = Nr, v = Symbol.for(\"react.element\"), pe = Symbol.for(\"react.fragment\"), G = Object.prototype.hasOwnProperty, ne = Y.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, ee = { key: !0, ref: !0, __self: !0, __source: !0 };\n  function H(K, D, J) {\n    var I, W = {}, X = null, k = null;\n    J !== void 0 && (X = \"\" + J), D.key !== void 0 && (X = \"\" + D.key), D.ref !== void 0 && (k = D.ref);\n    for (I in D)\n      G.call(D, I) && !ee.hasOwnProperty(I) && (W[I] = D[I]);\n    if (K && K.defaultProps)\n      for (I in D = K.defaultProps, D)\n        W[I] === void 0 && (W[I] = D[I]);\n    return { $$typeof: v, type: K, key: X, ref: k, props: W, _owner: ne.current };\n  }\n  return Ge.Fragment = pe, Ge.jsx = H, Ge.jsxs = H, Ge;\n}\nvar He = {};\n/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar dt;\nfunction Ut() {\n  return dt || (dt = 1,  true && function() {\n    var Y = Nr, v = Symbol.for(\"react.element\"), pe = Symbol.for(\"react.portal\"), G = Symbol.for(\"react.fragment\"), ne = Symbol.for(\"react.strict_mode\"), ee = Symbol.for(\"react.profiler\"), H = Symbol.for(\"react.provider\"), K = Symbol.for(\"react.context\"), D = Symbol.for(\"react.forward_ref\"), J = Symbol.for(\"react.suspense\"), I = Symbol.for(\"react.suspense_list\"), W = Symbol.for(\"react.memo\"), X = Symbol.for(\"react.lazy\"), k = Symbol.for(\"react.offscreen\"), fe = Symbol.iterator, Ie = \"@@iterator\";\n    function ae(t) {\n      if (t === null || typeof t != \"object\")\n        return null;\n      var i = fe && t[fe] || t[Ie];\n      return typeof i == \"function\" ? i : null;\n    }\n    var oe = Y.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n    function L(t) {\n      {\n        for (var i = arguments.length, f = new Array(i > 1 ? i - 1 : 0), c = 1; c < i; c++)\n          f[c - 1] = arguments[c];\n        he(\"error\", t, f);\n      }\n    }\n    function he(t, i, f) {\n      {\n        var c = oe.ReactDebugCurrentFrame, R = c.getStackAddendum();\n        R !== \"\" && (i += \"%s\", f = f.concat([R]));\n        var S = f.map(function(b) {\n          return String(b);\n        });\n        S.unshift(\"Warning: \" + i), Function.prototype.apply.call(console[t], console, S);\n      }\n    }\n    var ie = !1, N = !1, Q = !1, ce = !1, ve = !1, Re;\n    Re = Symbol.for(\"react.module.reference\");\n    function Ce(t) {\n      return !!(typeof t == \"string\" || typeof t == \"function\" || t === G || t === ee || ve || t === ne || t === J || t === I || ce || t === k || ie || N || Q || typeof t == \"object\" && t !== null && (t.$$typeof === X || t.$$typeof === W || t.$$typeof === H || t.$$typeof === K || t.$$typeof === D || // This needs to include all possible module reference object\n      // types supported by any Flight configuration anywhere since\n      // we don't know which Flight build this will end up being used\n      // with.\n      t.$$typeof === Re || t.getModuleId !== void 0));\n    }\n    function Ue(t, i, f) {\n      var c = t.displayName;\n      if (c)\n        return c;\n      var R = i.displayName || i.name || \"\";\n      return R !== \"\" ? f + \"(\" + R + \")\" : f;\n    }\n    function we(t) {\n      return t.displayName || \"Context\";\n    }\n    function Z(t) {\n      if (t == null)\n        return null;\n      if (typeof t.tag == \"number\" && L(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"), typeof t == \"function\")\n        return t.displayName || t.name || null;\n      if (typeof t == \"string\")\n        return t;\n      switch (t) {\n        case G:\n          return \"Fragment\";\n        case pe:\n          return \"Portal\";\n        case ee:\n          return \"Profiler\";\n        case ne:\n          return \"StrictMode\";\n        case J:\n          return \"Suspense\";\n        case I:\n          return \"SuspenseList\";\n      }\n      if (typeof t == \"object\")\n        switch (t.$$typeof) {\n          case K:\n            var i = t;\n            return we(i) + \".Consumer\";\n          case H:\n            var f = t;\n            return we(f._context) + \".Provider\";\n          case D:\n            return Ue(t, t.render, \"ForwardRef\");\n          case W:\n            var c = t.displayName || null;\n            return c !== null ? c : Z(t.type) || \"Memo\";\n          case X: {\n            var R = t, S = R._payload, b = R._init;\n            try {\n              return Z(b(S));\n            } catch {\n              return null;\n            }\n          }\n        }\n      return null;\n    }\n    var re = Object.assign, B = 0, ue, d, le, Se, n, s, h;\n    function C() {\n    }\n    C.__reactDisabledLog = !0;\n    function _() {\n      {\n        if (B === 0) {\n          ue = console.log, d = console.info, le = console.warn, Se = console.error, n = console.group, s = console.groupCollapsed, h = console.groupEnd;\n          var t = {\n            configurable: !0,\n            enumerable: !0,\n            value: C,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            info: t,\n            log: t,\n            warn: t,\n            error: t,\n            group: t,\n            groupCollapsed: t,\n            groupEnd: t\n          });\n        }\n        B++;\n      }\n    }\n    function P() {\n      {\n        if (B--, B === 0) {\n          var t = {\n            configurable: !0,\n            enumerable: !0,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            log: re({}, t, {\n              value: ue\n            }),\n            info: re({}, t, {\n              value: d\n            }),\n            warn: re({}, t, {\n              value: le\n            }),\n            error: re({}, t, {\n              value: Se\n            }),\n            group: re({}, t, {\n              value: n\n            }),\n            groupCollapsed: re({}, t, {\n              value: s\n            }),\n            groupEnd: re({}, t, {\n              value: h\n            })\n          });\n        }\n        B < 0 && L(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n      }\n    }\n    var j = oe.ReactCurrentDispatcher, T;\n    function w(t, i, f) {\n      {\n        if (T === void 0)\n          try {\n            throw Error();\n          } catch (R) {\n            var c = R.stack.trim().match(/\\n( *(at )?)/);\n            T = c && c[1] || \"\";\n          }\n        return `\n` + T + t;\n      }\n    }\n    var U = !1, me;\n    {\n      var yr = typeof WeakMap == \"function\" ? WeakMap : Map;\n      me = new yr();\n    }\n    function Je(t, i) {\n      if (!t || U)\n        return \"\";\n      {\n        var f = me.get(t);\n        if (f !== void 0)\n          return f;\n      }\n      var c;\n      U = !0;\n      var R = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var S;\n      S = j.current, j.current = null, _();\n      try {\n        if (i) {\n          var b = function() {\n            throw Error();\n          };\n          if (Object.defineProperty(b.prototype, \"props\", {\n            set: function() {\n              throw Error();\n            }\n          }), typeof Reflect == \"object\" && Reflect.construct) {\n            try {\n              Reflect.construct(b, []);\n            } catch (se) {\n              c = se;\n            }\n            Reflect.construct(t, [], b);\n          } else {\n            try {\n              b.call();\n            } catch (se) {\n              c = se;\n            }\n            t.call(b.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (se) {\n            c = se;\n          }\n          t();\n        }\n      } catch (se) {\n        if (se && c && typeof se.stack == \"string\") {\n          for (var m = se.stack.split(`\n`), z = c.stack.split(`\n`), F = m.length - 1, V = z.length - 1; F >= 1 && V >= 0 && m[F] !== z[V]; )\n            V--;\n          for (; F >= 1 && V >= 0; F--, V--)\n            if (m[F] !== z[V]) {\n              if (F !== 1 || V !== 1)\n                do\n                  if (F--, V--, V < 0 || m[F] !== z[V]) {\n                    var te = `\n` + m[F].replace(\" at new \", \" at \");\n                    return t.displayName && te.includes(\"<anonymous>\") && (te = te.replace(\"<anonymous>\", t.displayName)), typeof t == \"function\" && me.set(t, te), te;\n                  }\n                while (F >= 1 && V >= 0);\n              break;\n            }\n        }\n      } finally {\n        U = !1, j.current = S, P(), Error.prepareStackTrace = R;\n      }\n      var Ee = t ? t.displayName || t.name : \"\", ur = Ee ? w(Ee) : \"\";\n      return typeof t == \"function\" && me.set(t, ur), ur;\n    }\n    function Fe(t, i, f) {\n      return Je(t, !1);\n    }\n    function hr(t) {\n      var i = t.prototype;\n      return !!(i && i.isReactComponent);\n    }\n    function $e(t, i, f) {\n      if (t == null)\n        return \"\";\n      if (typeof t == \"function\")\n        return Je(t, hr(t));\n      if (typeof t == \"string\")\n        return w(t);\n      switch (t) {\n        case J:\n          return w(\"Suspense\");\n        case I:\n          return w(\"SuspenseList\");\n      }\n      if (typeof t == \"object\")\n        switch (t.$$typeof) {\n          case D:\n            return Fe(t.render);\n          case W:\n            return $e(t.type, i, f);\n          case X: {\n            var c = t, R = c._payload, S = c._init;\n            try {\n              return $e(S(R), i, f);\n            } catch {\n            }\n          }\n        }\n      return \"\";\n    }\n    var Te = Object.prototype.hasOwnProperty, Oe = {}, Xe = oe.ReactDebugCurrentFrame;\n    function Pe(t) {\n      if (t) {\n        var i = t._owner, f = $e(t.type, t._source, i ? i.type : null);\n        Xe.setExtraStackFrame(f);\n      } else\n        Xe.setExtraStackFrame(null);\n    }\n    function de(t, i, f, c, R) {\n      {\n        var S = Function.call.bind(Te);\n        for (var b in t)\n          if (S(t, b)) {\n            var m = void 0;\n            try {\n              if (typeof t[b] != \"function\") {\n                var z = Error((c || \"React class\") + \": \" + f + \" type `\" + b + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof t[b] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                throw z.name = \"Invariant Violation\", z;\n              }\n              m = t[b](i, b, c, f, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n            } catch (F) {\n              m = F;\n            }\n            m && !(m instanceof Error) && (Pe(R), L(\"%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\", c || \"React class\", f, b, typeof m), Pe(null)), m instanceof Error && !(m.message in Oe) && (Oe[m.message] = !0, Pe(R), L(\"Failed %s type: %s\", f, m.message), Pe(null));\n          }\n      }\n    }\n    var ke = Array.isArray;\n    function Le(t) {\n      return ke(t);\n    }\n    function Qe(t) {\n      {\n        var i = typeof Symbol == \"function\" && Symbol.toStringTag, f = i && t[Symbol.toStringTag] || t.constructor.name || \"Object\";\n        return f;\n      }\n    }\n    function Ze(t) {\n      try {\n        return Ve(t), !1;\n      } catch {\n        return !0;\n      }\n    }\n    function Ve(t) {\n      return \"\" + t;\n    }\n    function Ye(t) {\n      if (Ze(t))\n        return L(\"The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.\", Qe(t)), Ve(t);\n    }\n    var ge = oe.ReactCurrentOwner, mr = {\n      key: !0,\n      ref: !0,\n      __self: !0,\n      __source: !0\n    }, er, rr, je;\n    je = {};\n    function gr(t) {\n      if (Te.call(t, \"ref\")) {\n        var i = Object.getOwnPropertyDescriptor(t, \"ref\").get;\n        if (i && i.isReactWarning)\n          return !1;\n      }\n      return t.ref !== void 0;\n    }\n    function _r(t) {\n      if (Te.call(t, \"key\")) {\n        var i = Object.getOwnPropertyDescriptor(t, \"key\").get;\n        if (i && i.isReactWarning)\n          return !1;\n      }\n      return t.key !== void 0;\n    }\n    function br(t, i) {\n      if (typeof t.ref == \"string\" && ge.current && i && ge.current.stateNode !== i) {\n        var f = Z(ge.current.type);\n        je[f] || (L('Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', Z(ge.current.type), t.ref), je[f] = !0);\n      }\n    }\n    function _e(t, i) {\n      {\n        var f = function() {\n          er || (er = !0, L(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", i));\n        };\n        f.isReactWarning = !0, Object.defineProperty(t, \"key\", {\n          get: f,\n          configurable: !0\n        });\n      }\n    }\n    function tr(t, i) {\n      {\n        var f = function() {\n          rr || (rr = !0, L(\"%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", i));\n        };\n        f.isReactWarning = !0, Object.defineProperty(t, \"ref\", {\n          get: f,\n          configurable: !0\n        });\n      }\n    }\n    var Er = function(t, i, f, c, R, S, b) {\n      var m = {\n        // This tag allows us to uniquely identify this as a React Element\n        $$typeof: v,\n        // Built-in properties that belong on the element\n        type: t,\n        key: i,\n        ref: f,\n        props: b,\n        // Record the component responsible for creating this element.\n        _owner: S\n      };\n      return m._store = {}, Object.defineProperty(m._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: !1\n      }), Object.defineProperty(m, \"_self\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: c\n      }), Object.defineProperty(m, \"_source\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: R\n      }), Object.freeze && (Object.freeze(m.props), Object.freeze(m)), m;\n    };\n    function Rr(t, i, f, c, R) {\n      {\n        var S, b = {}, m = null, z = null;\n        f !== void 0 && (Ye(f), m = \"\" + f), _r(i) && (Ye(i.key), m = \"\" + i.key), gr(i) && (z = i.ref, br(i, R));\n        for (S in i)\n          Te.call(i, S) && !mr.hasOwnProperty(S) && (b[S] = i[S]);\n        if (t && t.defaultProps) {\n          var F = t.defaultProps;\n          for (S in F)\n            b[S] === void 0 && (b[S] = F[S]);\n        }\n        if (m || z) {\n          var V = typeof t == \"function\" ? t.displayName || t.name || \"Unknown\" : t;\n          m && _e(b, V), z && tr(b, V);\n        }\n        return Er(t, m, z, R, c, ge.current, b);\n      }\n    }\n    var Ne = oe.ReactCurrentOwner, nr = oe.ReactDebugCurrentFrame;\n    function ye(t) {\n      if (t) {\n        var i = t._owner, f = $e(t.type, t._source, i ? i.type : null);\n        nr.setExtraStackFrame(f);\n      } else\n        nr.setExtraStackFrame(null);\n    }\n    var Ae;\n    Ae = !1;\n    function be(t) {\n      return typeof t == \"object\" && t !== null && t.$$typeof === v;\n    }\n    function xe() {\n      {\n        if (Ne.current) {\n          var t = Z(Ne.current.type);\n          if (t)\n            return `\n\nCheck the render method of \\`` + t + \"`.\";\n        }\n        return \"\";\n      }\n    }\n    function Cr(t) {\n      {\n        if (t !== void 0) {\n          var i = t.fileName.replace(/^.*[\\\\\\/]/, \"\"), f = t.lineNumber;\n          return `\n\nCheck your code at ` + i + \":\" + f + \".\";\n        }\n        return \"\";\n      }\n    }\n    var ar = {};\n    function wr(t) {\n      {\n        var i = xe();\n        if (!i) {\n          var f = typeof t == \"string\" ? t : t.displayName || t.name;\n          f && (i = `\n\nCheck the top-level render call using <` + f + \">.\");\n        }\n        return i;\n      }\n    }\n    function or(t, i) {\n      {\n        if (!t._store || t._store.validated || t.key != null)\n          return;\n        t._store.validated = !0;\n        var f = wr(i);\n        if (ar[f])\n          return;\n        ar[f] = !0;\n        var c = \"\";\n        t && t._owner && t._owner !== Ne.current && (c = \" It was passed a child from \" + Z(t._owner.type) + \".\"), ye(t), L('Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', f, c), ye(null);\n      }\n    }\n    function ir(t, i) {\n      {\n        if (typeof t != \"object\")\n          return;\n        if (Le(t))\n          for (var f = 0; f < t.length; f++) {\n            var c = t[f];\n            be(c) && or(c, i);\n          }\n        else if (be(t))\n          t._store && (t._store.validated = !0);\n        else if (t) {\n          var R = ae(t);\n          if (typeof R == \"function\" && R !== t.entries)\n            for (var S = R.call(t), b; !(b = S.next()).done; )\n              be(b.value) && or(b.value, i);\n        }\n      }\n    }\n    function De(t) {\n      {\n        var i = t.type;\n        if (i == null || typeof i == \"string\")\n          return;\n        var f;\n        if (typeof i == \"function\")\n          f = i.propTypes;\n        else if (typeof i == \"object\" && (i.$$typeof === D || // Note: Memo only checks outer props here.\n        // Inner props are checked in the reconciler.\n        i.$$typeof === W))\n          f = i.propTypes;\n        else\n          return;\n        if (f) {\n          var c = Z(i);\n          de(f, t.props, \"prop\", c, t);\n        } else if (i.PropTypes !== void 0 && !Ae) {\n          Ae = !0;\n          var R = Z(i);\n          L(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", R || \"Unknown\");\n        }\n        typeof i.getDefaultProps == \"function\" && !i.getDefaultProps.isReactClassApproved && L(\"getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.\");\n      }\n    }\n    function Be(t) {\n      {\n        for (var i = Object.keys(t.props), f = 0; f < i.length; f++) {\n          var c = i[f];\n          if (c !== \"children\" && c !== \"key\") {\n            ye(t), L(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", c), ye(null);\n            break;\n          }\n        }\n        t.ref !== null && (ye(t), L(\"Invalid attribute `ref` supplied to `React.Fragment`.\"), ye(null));\n      }\n    }\n    function ze(t, i, f, c, R, S) {\n      {\n        var b = Ce(t);\n        if (!b) {\n          var m = \"\";\n          (t === void 0 || typeof t == \"object\" && t !== null && Object.keys(t).length === 0) && (m += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\");\n          var z = Cr(R);\n          z ? m += z : m += xe();\n          var F;\n          t === null ? F = \"null\" : Le(t) ? F = \"array\" : t !== void 0 && t.$$typeof === v ? (F = \"<\" + (Z(t.type) || \"Unknown\") + \" />\", m = \" Did you accidentally export a JSX literal instead of a component?\") : F = typeof t, L(\"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\", F, m);\n        }\n        var V = Rr(t, i, f, R, S);\n        if (V == null)\n          return V;\n        if (b) {\n          var te = i.children;\n          if (te !== void 0)\n            if (c)\n              if (Le(te)) {\n                for (var Ee = 0; Ee < te.length; Ee++)\n                  ir(te[Ee], t);\n                Object.freeze && Object.freeze(te);\n              } else\n                L(\"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\");\n            else\n              ir(te, t);\n        }\n        return t === G ? Be(V) : De(V), V;\n      }\n    }\n    function Sr(t, i, f) {\n      return ze(t, i, f, !0);\n    }\n    function Tr(t, i, f) {\n      return ze(t, i, f, !1);\n    }\n    var Or = Tr, Pr = Sr;\n    He.Fragment = G, He.jsx = Or, He.jsxs = Pr;\n  }()), He;\n}\n false ? 0 : Lr.exports = Ut();\nvar Yt = Lr.exports;\nconst Bt = Yt.jsx;\nfunction zt(...Y) {\n  return Y.filter(Boolean).map((v) => v.trim()).join(\" \");\n}\nconst qt = Nr.forwardRef(\n  ({\n    icon: Y,\n    onClick: v,\n    as: pe,\n    weight: G,\n    fill: ne = !1,\n    grade: ee,\n    size: H,\n    style: K,\n    color: D,\n    className: J,\n    ...I\n  }, W) => {\n    const X = v !== void 0 ? \"button\" : pe ?? \"span\", k = { color: D, ...K };\n    return ne && (k.fontVariationSettings = [k.fontVariationSettings, '\"FILL\" 1'].filter(Boolean).join(\", \")), G && (k.fontVariationSettings = [k.fontVariationSettings, `\"wght\" ${G}`].filter(Boolean).join(\", \")), ee && (k.fontVariationSettings = [k.fontVariationSettings, `\"GRAD\" ${ee}`].filter(Boolean).join(\", \")), H && (k.fontVariationSettings = [k.fontVariationSettings, `\"opsz\" ${H}`].filter(Boolean).join(\", \"), k.fontSize = H), /* @__PURE__ */ Bt(\n      X,\n      {\n        ...I,\n        ref: W,\n        style: k,\n        onClick: v,\n        className: zt(\"material-symbols\", J),\n        children: Y\n      }\n    );\n  }\n);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWF0ZXJpYWwtc3ltYm9scy9kaXN0L2luZGV4LmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxXQUFXLGFBQWEsU0FBUyxTQUFTLGFBQWE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsR0FBRztBQUNILEdBQUc7QUFDSCxHQUFHO0FBQ0gsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsZUFBZSxTQUFTO0FBQzdGO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsc0JBQXNCO0FBQ3ZEO0FBQ0E7QUFDQSxtSUFBbUksa0NBQWtDO0FBQ3JLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7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QixtQkFBbUIsV0FBVztBQUM5QixtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRjtBQUMvRjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLG1HQUFtRztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsc0JBQXNCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxNQUFxQyxHQUFHLENBQWlCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCw0REFBNEQ7QUFDNUQsbUxBQW1MLEVBQUUscUdBQXFHLEdBQUcsb0dBQW9HLEVBQUU7QUFDblk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93YWxsZXQtcm9uaW4vLi9ub2RlX21vZHVsZXMvcmVhY3QtbWF0ZXJpYWwtc3ltYm9scy9kaXN0L2luZGV4LmVzLmpzP2M3MjciXSwic291cmNlc0NvbnRlbnQiOlsidmFyIExyID0geyBleHBvcnRzOiB7fSB9LCBHZSA9IHt9LCBWciA9IHsgZXhwb3J0czoge30gfSwgZyA9IHt9O1xuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xudmFyIGZ0O1xuZnVuY3Rpb24gTnQoKSB7XG4gIGlmIChmdClcbiAgICByZXR1cm4gZztcbiAgZnQgPSAxO1xuICB2YXIgWSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpLCB2ID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSwgcGUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksIEcgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIiksIG5lID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpLCBlZSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKSwgSCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLCBLID0gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpLCBEID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLCBKID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIiksIEkgPSBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKSwgVyA9IFN5bWJvbC5pdGVyYXRvcjtcbiAgZnVuY3Rpb24gWChuKSB7XG4gICAgcmV0dXJuIG4gPT09IG51bGwgfHwgdHlwZW9mIG4gIT0gXCJvYmplY3RcIiA/IG51bGwgOiAobiA9IFcgJiYgbltXXSB8fCBuW1wiQEBpdGVyYXRvclwiXSwgdHlwZW9mIG4gPT0gXCJmdW5jdGlvblwiID8gbiA6IG51bGwpO1xuICB9XG4gIHZhciBrID0geyBpc01vdW50ZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhMTtcbiAgfSwgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgfSwgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24oKSB7XG4gIH0sIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gIH0gfSwgZmUgPSBPYmplY3QuYXNzaWduLCBJZSA9IHt9O1xuICBmdW5jdGlvbiBhZShuLCBzLCBoKSB7XG4gICAgdGhpcy5wcm9wcyA9IG4sIHRoaXMuY29udGV4dCA9IHMsIHRoaXMucmVmcyA9IEllLCB0aGlzLnVwZGF0ZXIgPSBoIHx8IGs7XG4gIH1cbiAgYWUucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fSwgYWUucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24obiwgcykge1xuICAgIGlmICh0eXBlb2YgbiAhPSBcIm9iamVjdFwiICYmIHR5cGVvZiBuICE9IFwiZnVuY3Rpb25cIiAmJiBuICE9IG51bGwpXG4gICAgICB0aHJvdyBFcnJvcihcInNldFN0YXRlKC4uLik6IHRha2VzIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMgdG8gdXBkYXRlIG9yIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzLlwiKTtcbiAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsIG4sIHMsIFwic2V0U3RhdGVcIik7XG4gIH0sIGFlLnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uKG4pIHtcbiAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMsIG4sIFwiZm9yY2VVcGRhdGVcIik7XG4gIH07XG4gIGZ1bmN0aW9uIG9lKCkge1xuICB9XG4gIG9lLnByb3RvdHlwZSA9IGFlLnByb3RvdHlwZTtcbiAgZnVuY3Rpb24gTChuLCBzLCBoKSB7XG4gICAgdGhpcy5wcm9wcyA9IG4sIHRoaXMuY29udGV4dCA9IHMsIHRoaXMucmVmcyA9IEllLCB0aGlzLnVwZGF0ZXIgPSBoIHx8IGs7XG4gIH1cbiAgdmFyIGhlID0gTC5wcm90b3R5cGUgPSBuZXcgb2UoKTtcbiAgaGUuY29uc3RydWN0b3IgPSBMLCBmZShoZSwgYWUucHJvdG90eXBlKSwgaGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSAhMDtcbiAgdmFyIGllID0gQXJyYXkuaXNBcnJheSwgTiA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIFEgPSB7IGN1cnJlbnQ6IG51bGwgfSwgY2UgPSB7IGtleTogITAsIHJlZjogITAsIF9fc2VsZjogITAsIF9fc291cmNlOiAhMCB9O1xuICBmdW5jdGlvbiB2ZShuLCBzLCBoKSB7XG4gICAgdmFyIEMsIF8gPSB7fSwgUCA9IG51bGwsIGogPSBudWxsO1xuICAgIGlmIChzICE9IG51bGwpXG4gICAgICBmb3IgKEMgaW4gcy5yZWYgIT09IHZvaWQgMCAmJiAoaiA9IHMucmVmKSwgcy5rZXkgIT09IHZvaWQgMCAmJiAoUCA9IFwiXCIgKyBzLmtleSksIHMpXG4gICAgICAgIE4uY2FsbChzLCBDKSAmJiAhY2UuaGFzT3duUHJvcGVydHkoQykgJiYgKF9bQ10gPSBzW0NdKTtcbiAgICB2YXIgVCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICAgIGlmIChUID09PSAxKVxuICAgICAgXy5jaGlsZHJlbiA9IGg7XG4gICAgZWxzZSBpZiAoMSA8IFQpIHtcbiAgICAgIGZvciAodmFyIHcgPSBBcnJheShUKSwgVSA9IDA7IFUgPCBUOyBVKyspXG4gICAgICAgIHdbVV0gPSBhcmd1bWVudHNbVSArIDJdO1xuICAgICAgXy5jaGlsZHJlbiA9IHc7XG4gICAgfVxuICAgIGlmIChuICYmIG4uZGVmYXVsdFByb3BzKVxuICAgICAgZm9yIChDIGluIFQgPSBuLmRlZmF1bHRQcm9wcywgVClcbiAgICAgICAgX1tDXSA9PT0gdm9pZCAwICYmIChfW0NdID0gVFtDXSk7XG4gICAgcmV0dXJuIHsgJCR0eXBlb2Y6IFksIHR5cGU6IG4sIGtleTogUCwgcmVmOiBqLCBwcm9wczogXywgX293bmVyOiBRLmN1cnJlbnQgfTtcbiAgfVxuICBmdW5jdGlvbiBSZShuLCBzKSB7XG4gICAgcmV0dXJuIHsgJCR0eXBlb2Y6IFksIHR5cGU6IG4udHlwZSwga2V5OiBzLCByZWY6IG4ucmVmLCBwcm9wczogbi5wcm9wcywgX293bmVyOiBuLl9vd25lciB9O1xuICB9XG4gIGZ1bmN0aW9uIENlKG4pIHtcbiAgICByZXR1cm4gdHlwZW9mIG4gPT0gXCJvYmplY3RcIiAmJiBuICE9PSBudWxsICYmIG4uJCR0eXBlb2YgPT09IFk7XG4gIH1cbiAgZnVuY3Rpb24gVWUobikge1xuICAgIHZhciBzID0geyBcIj1cIjogXCI9MFwiLCBcIjpcIjogXCI9MlwiIH07XG4gICAgcmV0dXJuIFwiJFwiICsgbi5yZXBsYWNlKC9bPTpdL2csIGZ1bmN0aW9uKGgpIHtcbiAgICAgIHJldHVybiBzW2hdO1xuICAgIH0pO1xuICB9XG4gIHZhciB3ZSA9IC9cXC8rL2c7XG4gIGZ1bmN0aW9uIFoobiwgcykge1xuICAgIHJldHVybiB0eXBlb2YgbiA9PSBcIm9iamVjdFwiICYmIG4gIT09IG51bGwgJiYgbi5rZXkgIT0gbnVsbCA/IFVlKFwiXCIgKyBuLmtleSkgOiBzLnRvU3RyaW5nKDM2KTtcbiAgfVxuICBmdW5jdGlvbiByZShuLCBzLCBoLCBDLCBfKSB7XG4gICAgdmFyIFAgPSB0eXBlb2YgbjtcbiAgICAoUCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBQID09PSBcImJvb2xlYW5cIikgJiYgKG4gPSBudWxsKTtcbiAgICB2YXIgaiA9ICExO1xuICAgIGlmIChuID09PSBudWxsKVxuICAgICAgaiA9ICEwO1xuICAgIGVsc2VcbiAgICAgIHN3aXRjaCAoUCkge1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICBqID0gITA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICBzd2l0Y2ggKG4uJCR0eXBlb2YpIHtcbiAgICAgICAgICAgIGNhc2UgWTpcbiAgICAgICAgICAgIGNhc2UgdjpcbiAgICAgICAgICAgICAgaiA9ICEwO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICBpZiAoailcbiAgICAgIHJldHVybiBqID0gbiwgXyA9IF8oaiksIG4gPSBDID09PSBcIlwiID8gXCIuXCIgKyBaKGosIDApIDogQywgaWUoXykgPyAoaCA9IFwiXCIsIG4gIT0gbnVsbCAmJiAoaCA9IG4ucmVwbGFjZSh3ZSwgXCIkJi9cIikgKyBcIi9cIiksIHJlKF8sIHMsIGgsIFwiXCIsIGZ1bmN0aW9uKFUpIHtcbiAgICAgICAgcmV0dXJuIFU7XG4gICAgICB9KSkgOiBfICE9IG51bGwgJiYgKENlKF8pICYmIChfID0gUmUoXywgaCArICghXy5rZXkgfHwgaiAmJiBqLmtleSA9PT0gXy5rZXkgPyBcIlwiIDogKFwiXCIgKyBfLmtleSkucmVwbGFjZSh3ZSwgXCIkJi9cIikgKyBcIi9cIikgKyBuKSksIHMucHVzaChfKSksIDE7XG4gICAgaWYgKGogPSAwLCBDID0gQyA9PT0gXCJcIiA/IFwiLlwiIDogQyArIFwiOlwiLCBpZShuKSlcbiAgICAgIGZvciAodmFyIFQgPSAwOyBUIDwgbi5sZW5ndGg7IFQrKykge1xuICAgICAgICBQID0gbltUXTtcbiAgICAgICAgdmFyIHcgPSBDICsgWihQLCBUKTtcbiAgICAgICAgaiArPSByZShQLCBzLCBoLCB3LCBfKTtcbiAgICAgIH1cbiAgICBlbHNlIGlmICh3ID0gWChuKSwgdHlwZW9mIHcgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgZm9yIChuID0gdy5jYWxsKG4pLCBUID0gMDsgIShQID0gbi5uZXh0KCkpLmRvbmU7IClcbiAgICAgICAgUCA9IFAudmFsdWUsIHcgPSBDICsgWihQLCBUKyspLCBqICs9IHJlKFAsIHMsIGgsIHcsIF8pO1xuICAgIGVsc2UgaWYgKFAgPT09IFwib2JqZWN0XCIpXG4gICAgICB0aHJvdyBzID0gU3RyaW5nKG4pLCBFcnJvcihcIk9iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogXCIgKyAocyA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIiA/IFwib2JqZWN0IHdpdGgga2V5cyB7XCIgKyBPYmplY3Qua2V5cyhuKS5qb2luKFwiLCBcIikgKyBcIn1cIiA6IHMpICsgXCIpLiBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5IGluc3RlYWQuXCIpO1xuICAgIHJldHVybiBqO1xuICB9XG4gIGZ1bmN0aW9uIEIobiwgcywgaCkge1xuICAgIGlmIChuID09IG51bGwpXG4gICAgICByZXR1cm4gbjtcbiAgICB2YXIgQyA9IFtdLCBfID0gMDtcbiAgICByZXR1cm4gcmUobiwgQywgXCJcIiwgXCJcIiwgZnVuY3Rpb24oUCkge1xuICAgICAgcmV0dXJuIHMuY2FsbChoLCBQLCBfKyspO1xuICAgIH0pLCBDO1xuICB9XG4gIGZ1bmN0aW9uIHVlKG4pIHtcbiAgICBpZiAobi5fc3RhdHVzID09PSAtMSkge1xuICAgICAgdmFyIHMgPSBuLl9yZXN1bHQ7XG4gICAgICBzID0gcygpLCBzLnRoZW4oZnVuY3Rpb24oaCkge1xuICAgICAgICAobi5fc3RhdHVzID09PSAwIHx8IG4uX3N0YXR1cyA9PT0gLTEpICYmIChuLl9zdGF0dXMgPSAxLCBuLl9yZXN1bHQgPSBoKTtcbiAgICAgIH0sIGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgKG4uX3N0YXR1cyA9PT0gMCB8fCBuLl9zdGF0dXMgPT09IC0xKSAmJiAobi5fc3RhdHVzID0gMiwgbi5fcmVzdWx0ID0gaCk7XG4gICAgICB9KSwgbi5fc3RhdHVzID09PSAtMSAmJiAobi5fc3RhdHVzID0gMCwgbi5fcmVzdWx0ID0gcyk7XG4gICAgfVxuICAgIGlmIChuLl9zdGF0dXMgPT09IDEpXG4gICAgICByZXR1cm4gbi5fcmVzdWx0LmRlZmF1bHQ7XG4gICAgdGhyb3cgbi5fcmVzdWx0O1xuICB9XG4gIHZhciBkID0geyBjdXJyZW50OiBudWxsIH0sIGxlID0geyB0cmFuc2l0aW9uOiBudWxsIH0sIFNlID0geyBSZWFjdEN1cnJlbnREaXNwYXRjaGVyOiBkLCBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZzogbGUsIFJlYWN0Q3VycmVudE93bmVyOiBRIH07XG4gIHJldHVybiBnLkNoaWxkcmVuID0geyBtYXA6IEIsIGZvckVhY2g6IGZ1bmN0aW9uKG4sIHMsIGgpIHtcbiAgICBCKG4sIGZ1bmN0aW9uKCkge1xuICAgICAgcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sIGgpO1xuICB9LCBjb3VudDogZnVuY3Rpb24obikge1xuICAgIHZhciBzID0gMDtcbiAgICByZXR1cm4gQihuLCBmdW5jdGlvbigpIHtcbiAgICAgIHMrKztcbiAgICB9KSwgcztcbiAgfSwgdG9BcnJheTogZnVuY3Rpb24obikge1xuICAgIHJldHVybiBCKG4sIGZ1bmN0aW9uKHMpIHtcbiAgICAgIHJldHVybiBzO1xuICAgIH0pIHx8IFtdO1xuICB9LCBvbmx5OiBmdW5jdGlvbihuKSB7XG4gICAgaWYgKCFDZShuKSlcbiAgICAgIHRocm93IEVycm9yKFwiUmVhY3QuQ2hpbGRyZW4ub25seSBleHBlY3RlZCB0byByZWNlaXZlIGEgc2luZ2xlIFJlYWN0IGVsZW1lbnQgY2hpbGQuXCIpO1xuICAgIHJldHVybiBuO1xuICB9IH0sIGcuQ29tcG9uZW50ID0gYWUsIGcuRnJhZ21lbnQgPSBwZSwgZy5Qcm9maWxlciA9IG5lLCBnLlB1cmVDb21wb25lbnQgPSBMLCBnLlN0cmljdE1vZGUgPSBHLCBnLlN1c3BlbnNlID0gRCwgZy5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCA9IFNlLCBnLmNsb25lRWxlbWVudCA9IGZ1bmN0aW9uKG4sIHMsIGgpIHtcbiAgICBpZiAobiA9PSBudWxsKVxuICAgICAgdGhyb3cgRXJyb3IoXCJSZWFjdC5jbG9uZUVsZW1lbnQoLi4uKTogVGhlIGFyZ3VtZW50IG11c3QgYmUgYSBSZWFjdCBlbGVtZW50LCBidXQgeW91IHBhc3NlZCBcIiArIG4gKyBcIi5cIik7XG4gICAgdmFyIEMgPSBmZSh7fSwgbi5wcm9wcyksIF8gPSBuLmtleSwgUCA9IG4ucmVmLCBqID0gbi5fb3duZXI7XG4gICAgaWYgKHMgIT0gbnVsbCkge1xuICAgICAgaWYgKHMucmVmICE9PSB2b2lkIDAgJiYgKFAgPSBzLnJlZiwgaiA9IFEuY3VycmVudCksIHMua2V5ICE9PSB2b2lkIDAgJiYgKF8gPSBcIlwiICsgcy5rZXkpLCBuLnR5cGUgJiYgbi50eXBlLmRlZmF1bHRQcm9wcylcbiAgICAgICAgdmFyIFQgPSBuLnR5cGUuZGVmYXVsdFByb3BzO1xuICAgICAgZm9yICh3IGluIHMpXG4gICAgICAgIE4uY2FsbChzLCB3KSAmJiAhY2UuaGFzT3duUHJvcGVydHkodykgJiYgKENbd10gPSBzW3ddID09PSB2b2lkIDAgJiYgVCAhPT0gdm9pZCAwID8gVFt3XSA6IHNbd10pO1xuICAgIH1cbiAgICB2YXIgdyA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICAgIGlmICh3ID09PSAxKVxuICAgICAgQy5jaGlsZHJlbiA9IGg7XG4gICAgZWxzZSBpZiAoMSA8IHcpIHtcbiAgICAgIFQgPSBBcnJheSh3KTtcbiAgICAgIGZvciAodmFyIFUgPSAwOyBVIDwgdzsgVSsrKVxuICAgICAgICBUW1VdID0gYXJndW1lbnRzW1UgKyAyXTtcbiAgICAgIEMuY2hpbGRyZW4gPSBUO1xuICAgIH1cbiAgICByZXR1cm4geyAkJHR5cGVvZjogWSwgdHlwZTogbi50eXBlLCBrZXk6IF8sIHJlZjogUCwgcHJvcHM6IEMsIF9vd25lcjogaiB9O1xuICB9LCBnLmNyZWF0ZUNvbnRleHQgPSBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuIG4gPSB7ICQkdHlwZW9mOiBILCBfY3VycmVudFZhbHVlOiBuLCBfY3VycmVudFZhbHVlMjogbiwgX3RocmVhZENvdW50OiAwLCBQcm92aWRlcjogbnVsbCwgQ29uc3VtZXI6IG51bGwsIF9kZWZhdWx0VmFsdWU6IG51bGwsIF9nbG9iYWxOYW1lOiBudWxsIH0sIG4uUHJvdmlkZXIgPSB7ICQkdHlwZW9mOiBlZSwgX2NvbnRleHQ6IG4gfSwgbi5Db25zdW1lciA9IG47XG4gIH0sIGcuY3JlYXRlRWxlbWVudCA9IHZlLCBnLmNyZWF0ZUZhY3RvcnkgPSBmdW5jdGlvbihuKSB7XG4gICAgdmFyIHMgPSB2ZS5iaW5kKG51bGwsIG4pO1xuICAgIHJldHVybiBzLnR5cGUgPSBuLCBzO1xuICB9LCBnLmNyZWF0ZVJlZiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7IGN1cnJlbnQ6IG51bGwgfTtcbiAgfSwgZy5mb3J3YXJkUmVmID0gZnVuY3Rpb24obikge1xuICAgIHJldHVybiB7ICQkdHlwZW9mOiBLLCByZW5kZXI6IG4gfTtcbiAgfSwgZy5pc1ZhbGlkRWxlbWVudCA9IENlLCBnLmxhenkgPSBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuIHsgJCR0eXBlb2Y6IEksIF9wYXlsb2FkOiB7IF9zdGF0dXM6IC0xLCBfcmVzdWx0OiBuIH0sIF9pbml0OiB1ZSB9O1xuICB9LCBnLm1lbW8gPSBmdW5jdGlvbihuLCBzKSB7XG4gICAgcmV0dXJuIHsgJCR0eXBlb2Y6IEosIHR5cGU6IG4sIGNvbXBhcmU6IHMgPT09IHZvaWQgMCA/IG51bGwgOiBzIH07XG4gIH0sIGcuc3RhcnRUcmFuc2l0aW9uID0gZnVuY3Rpb24obikge1xuICAgIHZhciBzID0gbGUudHJhbnNpdGlvbjtcbiAgICBsZS50cmFuc2l0aW9uID0ge307XG4gICAgdHJ5IHtcbiAgICAgIG4oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgbGUudHJhbnNpdGlvbiA9IHM7XG4gICAgfVxuICB9LCBnLnVuc3RhYmxlX2FjdCA9IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IEVycm9yKFwiYWN0KC4uLikgaXMgbm90IHN1cHBvcnRlZCBpbiBwcm9kdWN0aW9uIGJ1aWxkcyBvZiBSZWFjdC5cIik7XG4gIH0sIGcudXNlQ2FsbGJhY2sgPSBmdW5jdGlvbihuLCBzKSB7XG4gICAgcmV0dXJuIGQuY3VycmVudC51c2VDYWxsYmFjayhuLCBzKTtcbiAgfSwgZy51c2VDb250ZXh0ID0gZnVuY3Rpb24obikge1xuICAgIHJldHVybiBkLmN1cnJlbnQudXNlQ29udGV4dChuKTtcbiAgfSwgZy51c2VEZWJ1Z1ZhbHVlID0gZnVuY3Rpb24oKSB7XG4gIH0sIGcudXNlRGVmZXJyZWRWYWx1ZSA9IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gZC5jdXJyZW50LnVzZURlZmVycmVkVmFsdWUobik7XG4gIH0sIGcudXNlRWZmZWN0ID0gZnVuY3Rpb24obiwgcykge1xuICAgIHJldHVybiBkLmN1cnJlbnQudXNlRWZmZWN0KG4sIHMpO1xuICB9LCBnLnVzZUlkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQuY3VycmVudC51c2VJZCgpO1xuICB9LCBnLnVzZUltcGVyYXRpdmVIYW5kbGUgPSBmdW5jdGlvbihuLCBzLCBoKSB7XG4gICAgcmV0dXJuIGQuY3VycmVudC51c2VJbXBlcmF0aXZlSGFuZGxlKG4sIHMsIGgpO1xuICB9LCBnLnVzZUluc2VydGlvbkVmZmVjdCA9IGZ1bmN0aW9uKG4sIHMpIHtcbiAgICByZXR1cm4gZC5jdXJyZW50LnVzZUluc2VydGlvbkVmZmVjdChuLCBzKTtcbiAgfSwgZy51c2VMYXlvdXRFZmZlY3QgPSBmdW5jdGlvbihuLCBzKSB7XG4gICAgcmV0dXJuIGQuY3VycmVudC51c2VMYXlvdXRFZmZlY3Qobiwgcyk7XG4gIH0sIGcudXNlTWVtbyA9IGZ1bmN0aW9uKG4sIHMpIHtcbiAgICByZXR1cm4gZC5jdXJyZW50LnVzZU1lbW8obiwgcyk7XG4gIH0sIGcudXNlUmVkdWNlciA9IGZ1bmN0aW9uKG4sIHMsIGgpIHtcbiAgICByZXR1cm4gZC5jdXJyZW50LnVzZVJlZHVjZXIobiwgcywgaCk7XG4gIH0sIGcudXNlUmVmID0gZnVuY3Rpb24obikge1xuICAgIHJldHVybiBkLmN1cnJlbnQudXNlUmVmKG4pO1xuICB9LCBnLnVzZVN0YXRlID0gZnVuY3Rpb24obikge1xuICAgIHJldHVybiBkLmN1cnJlbnQudXNlU3RhdGUobik7XG4gIH0sIGcudXNlU3luY0V4dGVybmFsU3RvcmUgPSBmdW5jdGlvbihuLCBzLCBoKSB7XG4gICAgcmV0dXJuIGQuY3VycmVudC51c2VTeW5jRXh0ZXJuYWxTdG9yZShuLCBzLCBoKTtcbiAgfSwgZy51c2VUcmFuc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQuY3VycmVudC51c2VUcmFuc2l0aW9uKCk7XG4gIH0sIGcudmVyc2lvbiA9IFwiMTguMi4wXCIsIGc7XG59XG52YXIgS2UgPSB7IGV4cG9ydHM6IHt9IH07XG4vKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5LZS5leHBvcnRzO1xudmFyIGN0O1xuZnVuY3Rpb24gTXQoKSB7XG4gIHJldHVybiBjdCB8fCAoY3QgPSAxLCBmdW5jdGlvbihZLCB2KSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGZ1bmN0aW9uKCkge1xuICAgICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA8IFwidVwiICYmIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0ID09IFwiZnVuY3Rpb25cIiAmJiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0KG5ldyBFcnJvcigpKTtcbiAgICAgIHZhciBwZSA9IFwiMTguMi4wXCIsIEcgPSBTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSwgbmUgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLCBlZSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSwgSCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSwgSyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKSwgRCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKSwgSiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLCBJID0gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpLCBXID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLCBYID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksIGsgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSwgZmUgPSBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKSwgSWUgPSBTeW1ib2wuZm9yKFwicmVhY3Qub2Zmc2NyZWVuXCIpLCBhZSA9IFN5bWJvbC5pdGVyYXRvciwgb2UgPSBcIkBAaXRlcmF0b3JcIjtcbiAgICAgIGZ1bmN0aW9uIEwoZSkge1xuICAgICAgICBpZiAoZSA9PT0gbnVsbCB8fCB0eXBlb2YgZSAhPSBcIm9iamVjdFwiKVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgciA9IGFlICYmIGVbYWVdIHx8IGVbb2VdO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHIgPT0gXCJmdW5jdGlvblwiID8gciA6IG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgaGUgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgY3VycmVudDogbnVsbFxuICAgICAgfSwgaWUgPSB7XG4gICAgICAgIHRyYW5zaXRpb246IG51bGxcbiAgICAgIH0sIE4gPSB7XG4gICAgICAgIGN1cnJlbnQ6IG51bGwsXG4gICAgICAgIC8vIFVzZWQgdG8gcmVwcm9kdWNlIGJlaGF2aW9yIG9mIGBiYXRjaGVkVXBkYXRlc2AgaW4gbGVnYWN5IG1vZGUuXG4gICAgICAgIGlzQmF0Y2hpbmdMZWdhY3k6ICExLFxuICAgICAgICBkaWRTY2hlZHVsZUxlZ2FjeVVwZGF0ZTogITFcbiAgICAgIH0sIFEgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgY3VycmVudDogbnVsbFxuICAgICAgfSwgY2UgPSB7fSwgdmUgPSBudWxsO1xuICAgICAgZnVuY3Rpb24gUmUoZSkge1xuICAgICAgICB2ZSA9IGU7XG4gICAgICB9XG4gICAgICBjZS5zZXRFeHRyYVN0YWNrRnJhbWUgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZlID0gZTtcbiAgICAgIH0sIGNlLmdldEN1cnJlbnRTdGFjayA9IG51bGwsIGNlLmdldFN0YWNrQWRkZW5kdW0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGUgPSBcIlwiO1xuICAgICAgICB2ZSAmJiAoZSArPSB2ZSk7XG4gICAgICAgIHZhciByID0gY2UuZ2V0Q3VycmVudFN0YWNrO1xuICAgICAgICByZXR1cm4gciAmJiAoZSArPSByKCkgfHwgXCJcIiksIGU7XG4gICAgICB9O1xuICAgICAgdmFyIENlID0gITEsIFVlID0gITEsIHdlID0gITEsIFogPSAhMSwgcmUgPSAhMSwgQiA9IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjogaGUsXG4gICAgICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnOiBpZSxcbiAgICAgICAgUmVhY3RDdXJyZW50T3duZXI6IFFcbiAgICAgIH07XG4gICAgICBCLlJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBjZSwgQi5SZWFjdEN1cnJlbnRBY3RRdWV1ZSA9IE47XG4gICAgICBmdW5jdGlvbiB1ZShlKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBmb3IgKHZhciByID0gYXJndW1lbnRzLmxlbmd0aCwgYSA9IG5ldyBBcnJheShyID4gMSA/IHIgLSAxIDogMCksIG8gPSAxOyBvIDwgcjsgbysrKVxuICAgICAgICAgICAgYVtvIC0gMV0gPSBhcmd1bWVudHNbb107XG4gICAgICAgICAgbGUoXCJ3YXJuXCIsIGUsIGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBkKGUpIHtcbiAgICAgICAge1xuICAgICAgICAgIGZvciAodmFyIHIgPSBhcmd1bWVudHMubGVuZ3RoLCBhID0gbmV3IEFycmF5KHIgPiAxID8gciAtIDEgOiAwKSwgbyA9IDE7IG8gPCByOyBvKyspXG4gICAgICAgICAgICBhW28gLSAxXSA9IGFyZ3VtZW50c1tvXTtcbiAgICAgICAgICBsZShcImVycm9yXCIsIGUsIGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBsZShlLCByLCBhKSB7XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbyA9IEIuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSwgdSA9IG8uZ2V0U3RhY2tBZGRlbmR1bSgpO1xuICAgICAgICAgIHUgIT09IFwiXCIgJiYgKHIgKz0gXCIlc1wiLCBhID0gYS5jb25jYXQoW3VdKSk7XG4gICAgICAgICAgdmFyIHAgPSBhLm1hcChmdW5jdGlvbihsKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKGwpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHAudW5zaGlmdChcIldhcm5pbmc6IFwiICsgciksIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbZV0sIGNvbnNvbGUsIHApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgU2UgPSB7fTtcbiAgICAgIGZ1bmN0aW9uIG4oZSwgcikge1xuICAgICAgICB7XG4gICAgICAgICAgdmFyIGEgPSBlLmNvbnN0cnVjdG9yLCBvID0gYSAmJiAoYS5kaXNwbGF5TmFtZSB8fCBhLm5hbWUpIHx8IFwiUmVhY3RDbGFzc1wiLCB1ID0gbyArIFwiLlwiICsgcjtcbiAgICAgICAgICBpZiAoU2VbdV0pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgZChcIkNhbid0IGNhbGwgJXMgb24gYSBjb21wb25lbnQgdGhhdCBpcyBub3QgeWV0IG1vdW50ZWQuIFRoaXMgaXMgYSBuby1vcCwgYnV0IGl0IG1pZ2h0IGluZGljYXRlIGEgYnVnIGluIHlvdXIgYXBwbGljYXRpb24uIEluc3RlYWQsIGFzc2lnbiB0byBgdGhpcy5zdGF0ZWAgZGlyZWN0bHkgb3IgZGVmaW5lIGEgYHN0YXRlID0ge307YCBjbGFzcyBwcm9wZXJ0eSB3aXRoIHRoZSBkZXNpcmVkIHN0YXRlIGluIHRoZSAlcyBjb21wb25lbnQuXCIsIHIsIG8pLCBTZVt1XSA9ICEwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgcyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICAgICAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2Ugd2Ugd2FudCB0byB0ZXN0LlxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAZmluYWxcbiAgICAgICAgICovXG4gICAgICAgIGlzTW91bnRlZDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICAgICAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICAgICAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICAgICAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAgICAgICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAgICAgICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24oZSwgciwgYSkge1xuICAgICAgICAgIG4oZSwgXCJmb3JjZVVwZGF0ZVwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cbiAgICAgICAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgICAgICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cbiAgICAgICAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICAgICAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24oZSwgciwgYSwgbykge1xuICAgICAgICAgIG4oZSwgXCJyZXBsYWNlU3RhdGVcIik7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICAgICAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAgICAgICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgICAgICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAgICAgICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAgICAgICAqIEBwYXJhbSB7P3N0cmluZ30gTmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uKGUsIHIsIGEsIG8pIHtcbiAgICAgICAgICBuKGUsIFwic2V0U3RhdGVcIik7XG4gICAgICAgIH1cbiAgICAgIH0sIGggPSBPYmplY3QuYXNzaWduLCBDID0ge307XG4gICAgICBPYmplY3QuZnJlZXplKEMpO1xuICAgICAgZnVuY3Rpb24gXyhlLCByLCBhKSB7XG4gICAgICAgIHRoaXMucHJvcHMgPSBlLCB0aGlzLmNvbnRleHQgPSByLCB0aGlzLnJlZnMgPSBDLCB0aGlzLnVwZGF0ZXIgPSBhIHx8IHM7XG4gICAgICB9XG4gICAgICBfLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge30sIF8ucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24oZSwgcikge1xuICAgICAgICBpZiAodHlwZW9mIGUgIT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgZSAhPSBcImZ1bmN0aW9uXCIgJiYgZSAhPSBudWxsKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInNldFN0YXRlKC4uLik6IHRha2VzIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMgdG8gdXBkYXRlIG9yIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzLlwiKTtcbiAgICAgICAgdGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLCBlLCByLCBcInNldFN0YXRlXCIpO1xuICAgICAgfSwgXy5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcywgZSwgXCJmb3JjZVVwZGF0ZVwiKTtcbiAgICAgIH07XG4gICAgICB7XG4gICAgICAgIHZhciBQID0ge1xuICAgICAgICAgIGlzTW91bnRlZDogW1wiaXNNb3VudGVkXCIsIFwiSW5zdGVhZCwgbWFrZSBzdXJlIHRvIGNsZWFuIHVwIHN1YnNjcmlwdGlvbnMgYW5kIHBlbmRpbmcgcmVxdWVzdHMgaW4gY29tcG9uZW50V2lsbFVubW91bnQgdG8gcHJldmVudCBtZW1vcnkgbGVha3MuXCJdLFxuICAgICAgICAgIHJlcGxhY2VTdGF0ZTogW1wicmVwbGFjZVN0YXRlXCIsIFwiUmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBzZXRTdGF0ZSBpbnN0ZWFkIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zMjM2KS5cIl1cbiAgICAgICAgfSwgaiA9IGZ1bmN0aW9uKGUsIHIpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXy5wcm90b3R5cGUsIGUsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHVlKFwiJXMoLi4uKSBpcyBkZXByZWNhdGVkIGluIHBsYWluIEphdmFTY3JpcHQgUmVhY3QgY2xhc3Nlcy4gJXNcIiwgclswXSwgclsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIFQgaW4gUClcbiAgICAgICAgICBQLmhhc093blByb3BlcnR5KFQpICYmIGooVCwgUFtUXSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB3KCkge1xuICAgICAgfVxuICAgICAgdy5wcm90b3R5cGUgPSBfLnByb3RvdHlwZTtcbiAgICAgIGZ1bmN0aW9uIFUoZSwgciwgYSkge1xuICAgICAgICB0aGlzLnByb3BzID0gZSwgdGhpcy5jb250ZXh0ID0gciwgdGhpcy5yZWZzID0gQywgdGhpcy51cGRhdGVyID0gYSB8fCBzO1xuICAgICAgfVxuICAgICAgdmFyIG1lID0gVS5wcm90b3R5cGUgPSBuZXcgdygpO1xuICAgICAgbWUuY29uc3RydWN0b3IgPSBVLCBoKG1lLCBfLnByb3RvdHlwZSksIG1lLmlzUHVyZVJlYWN0Q29tcG9uZW50ID0gITA7XG4gICAgICBmdW5jdGlvbiB5cigpIHtcbiAgICAgICAgdmFyIGUgPSB7XG4gICAgICAgICAgY3VycmVudDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gT2JqZWN0LnNlYWwoZSksIGU7XG4gICAgICB9XG4gICAgICB2YXIgSmUgPSBBcnJheS5pc0FycmF5O1xuICAgICAgZnVuY3Rpb24gRmUoZSkge1xuICAgICAgICByZXR1cm4gSmUoZSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBocihlKSB7XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgciA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC50b1N0cmluZ1RhZywgYSA9IHIgJiYgZVtTeW1ib2wudG9TdHJpbmdUYWddIHx8IGUuY29uc3RydWN0b3IubmFtZSB8fCBcIk9iamVjdFwiO1xuICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiAkZShlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIFRlKGUpLCAhMTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBUZShlKSB7XG4gICAgICAgIHJldHVybiBcIlwiICsgZTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIE9lKGUpIHtcbiAgICAgICAgaWYgKCRlKGUpKVxuICAgICAgICAgIHJldHVybiBkKFwiVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLiBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsIGhyKGUpKSwgVGUoZSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBYZShlLCByLCBhKSB7XG4gICAgICAgIHZhciBvID0gZS5kaXNwbGF5TmFtZTtcbiAgICAgICAgaWYgKG8pXG4gICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgIHZhciB1ID0gci5kaXNwbGF5TmFtZSB8fCByLm5hbWUgfHwgXCJcIjtcbiAgICAgICAgcmV0dXJuIHUgIT09IFwiXCIgPyBhICsgXCIoXCIgKyB1ICsgXCIpXCIgOiBhO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gUGUoZSkge1xuICAgICAgICByZXR1cm4gZS5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIjtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGRlKGUpIHtcbiAgICAgICAgaWYgKGUgPT0gbnVsbClcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiBlLnRhZyA9PSBcIm51bWJlclwiICYmIGQoXCJSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiKSwgdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIHJldHVybiBlLmRpc3BsYXlOYW1lIHx8IGUubmFtZSB8fCBudWxsO1xuICAgICAgICBpZiAodHlwZW9mIGUgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgc3dpdGNoIChlKSB7XG4gICAgICAgICAgY2FzZSBlZTpcbiAgICAgICAgICAgIHJldHVybiBcIkZyYWdtZW50XCI7XG4gICAgICAgICAgY2FzZSBuZTpcbiAgICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgICAgICAgIGNhc2UgSzpcbiAgICAgICAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG4gICAgICAgICAgY2FzZSBIOlxuICAgICAgICAgICAgcmV0dXJuIFwiU3RyaWN0TW9kZVwiO1xuICAgICAgICAgIGNhc2UgVzpcbiAgICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgICAgY2FzZSBYOlxuICAgICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VMaXN0XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlID09IFwib2JqZWN0XCIpXG4gICAgICAgICAgc3dpdGNoIChlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgICBjYXNlIEo6XG4gICAgICAgICAgICAgIHZhciByID0gZTtcbiAgICAgICAgICAgICAgcmV0dXJuIFBlKHIpICsgXCIuQ29uc3VtZXJcIjtcbiAgICAgICAgICAgIGNhc2UgRDpcbiAgICAgICAgICAgICAgdmFyIGEgPSBlO1xuICAgICAgICAgICAgICByZXR1cm4gUGUoYS5fY29udGV4dCkgKyBcIi5Qcm92aWRlclwiO1xuICAgICAgICAgICAgY2FzZSBJOlxuICAgICAgICAgICAgICByZXR1cm4gWGUoZSwgZS5yZW5kZXIsIFwiRm9yd2FyZFJlZlwiKTtcbiAgICAgICAgICAgIGNhc2UgazpcbiAgICAgICAgICAgICAgdmFyIG8gPSBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG4gICAgICAgICAgICAgIHJldHVybiBvICE9PSBudWxsID8gbyA6IGRlKGUudHlwZSkgfHwgXCJNZW1vXCI7XG4gICAgICAgICAgICBjYXNlIGZlOiB7XG4gICAgICAgICAgICAgIHZhciB1ID0gZSwgcCA9IHUuX3BheWxvYWQsIGwgPSB1Ll9pbml0O1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZShsKHApKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIGtlID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgTGUgPSB7XG4gICAgICAgIGtleTogITAsXG4gICAgICAgIHJlZjogITAsXG4gICAgICAgIF9fc2VsZjogITAsXG4gICAgICAgIF9fc291cmNlOiAhMFxuICAgICAgfSwgUWUsIFplLCBWZTtcbiAgICAgIFZlID0ge307XG4gICAgICBmdW5jdGlvbiBZZShlKSB7XG4gICAgICAgIGlmIChrZS5jYWxsKGUsIFwicmVmXCIpKSB7XG4gICAgICAgICAgdmFyIHIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIFwicmVmXCIpLmdldDtcbiAgICAgICAgICBpZiAociAmJiByLmlzUmVhY3RXYXJuaW5nKVxuICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlLnJlZiAhPT0gdm9pZCAwO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZ2UoZSkge1xuICAgICAgICBpZiAoa2UuY2FsbChlLCBcImtleVwiKSkge1xuICAgICAgICAgIHZhciByID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBcImtleVwiKS5nZXQ7XG4gICAgICAgICAgaWYgKHIgJiYgci5pc1JlYWN0V2FybmluZylcbiAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZS5rZXkgIT09IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG1yKGUsIHIpIHtcbiAgICAgICAgdmFyIGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBRZSB8fCAoUWUgPSAhMCwgZChcIiVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgdmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCBwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpXCIsIHIpKTtcbiAgICAgICAgfTtcbiAgICAgICAgYS5pc1JlYWN0V2FybmluZyA9ICEwLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJrZXlcIiwge1xuICAgICAgICAgIGdldDogYSxcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZXIoZSwgcikge1xuICAgICAgICB2YXIgYSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIFplIHx8IChaZSA9ICEwLCBkKFwiJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSB2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50IHByb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcylcIiwgcikpO1xuICAgICAgICB9O1xuICAgICAgICBhLmlzUmVhY3RXYXJuaW5nID0gITAsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInJlZlwiLCB7XG4gICAgICAgICAgZ2V0OiBhLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBycihlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZS5yZWYgPT0gXCJzdHJpbmdcIiAmJiBRLmN1cnJlbnQgJiYgZS5fX3NlbGYgJiYgUS5jdXJyZW50LnN0YXRlTm9kZSAhPT0gZS5fX3NlbGYpIHtcbiAgICAgICAgICB2YXIgciA9IGRlKFEuY3VycmVudC50eXBlKTtcbiAgICAgICAgICBWZVtyXSB8fCAoZCgnQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuIFN1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiBXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIHIsIGUucmVmKSwgVmVbcl0gPSAhMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBqZSA9IGZ1bmN0aW9uKGUsIHIsIGEsIG8sIHUsIHAsIGwpIHtcbiAgICAgICAgdmFyIHkgPSB7XG4gICAgICAgICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgICAgICAgJCR0eXBlb2Y6IEcsXG4gICAgICAgICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgICAgICAgIHR5cGU6IGUsXG4gICAgICAgICAga2V5OiByLFxuICAgICAgICAgIHJlZjogYSxcbiAgICAgICAgICBwcm9wczogbCxcbiAgICAgICAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgICAgICAgIF9vd25lcjogcFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4geS5fc3RvcmUgPSB7fSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHkuX3N0b3JlLCBcInZhbGlkYXRlZFwiLCB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgICAgdmFsdWU6ICExXG4gICAgICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoeSwgXCJfc2VsZlwiLCB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICB3cml0YWJsZTogITEsXG4gICAgICAgICAgdmFsdWU6IG9cbiAgICAgICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh5LCBcIl9zb3VyY2VcIiwge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgd3JpdGFibGU6ICExLFxuICAgICAgICAgIHZhbHVlOiB1XG4gICAgICAgIH0pLCBPYmplY3QuZnJlZXplICYmIChPYmplY3QuZnJlZXplKHkucHJvcHMpLCBPYmplY3QuZnJlZXplKHkpKSwgeTtcbiAgICAgIH07XG4gICAgICBmdW5jdGlvbiBncihlLCByLCBhKSB7XG4gICAgICAgIHZhciBvLCB1ID0ge30sIHAgPSBudWxsLCBsID0gbnVsbCwgeSA9IG51bGwsIEUgPSBudWxsO1xuICAgICAgICBpZiAociAhPSBudWxsKSB7XG4gICAgICAgICAgWWUocikgJiYgKGwgPSByLnJlZiwgcnIocikpLCBnZShyKSAmJiAoT2Uoci5rZXkpLCBwID0gXCJcIiArIHIua2V5KSwgeSA9IHIuX19zZWxmID09PSB2b2lkIDAgPyBudWxsIDogci5fX3NlbGYsIEUgPSByLl9fc291cmNlID09PSB2b2lkIDAgPyBudWxsIDogci5fX3NvdXJjZTtcbiAgICAgICAgICBmb3IgKG8gaW4gcilcbiAgICAgICAgICAgIGtlLmNhbGwociwgbykgJiYgIUxlLmhhc093blByb3BlcnR5KG8pICYmICh1W29dID0gcltvXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIE8gPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgICAgICAgaWYgKE8gPT09IDEpXG4gICAgICAgICAgdS5jaGlsZHJlbiA9IGE7XG4gICAgICAgIGVsc2UgaWYgKE8gPiAxKSB7XG4gICAgICAgICAgZm9yICh2YXIgQSA9IEFycmF5KE8pLCB4ID0gMDsgeCA8IE87IHgrKylcbiAgICAgICAgICAgIEFbeF0gPSBhcmd1bWVudHNbeCArIDJdO1xuICAgICAgICAgIE9iamVjdC5mcmVlemUgJiYgT2JqZWN0LmZyZWV6ZShBKSwgdS5jaGlsZHJlbiA9IEE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUgJiYgZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgICB2YXIgJCA9IGUuZGVmYXVsdFByb3BzO1xuICAgICAgICAgIGZvciAobyBpbiAkKVxuICAgICAgICAgICAgdVtvXSA9PT0gdm9pZCAwICYmICh1W29dID0gJFtvXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHAgfHwgbCkge1xuICAgICAgICAgIHZhciBNID0gdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiID8gZS5kaXNwbGF5TmFtZSB8fCBlLm5hbWUgfHwgXCJVbmtub3duXCIgOiBlO1xuICAgICAgICAgIHAgJiYgbXIodSwgTSksIGwgJiYgZXIodSwgTSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGplKGUsIHAsIGwsIHksIEUsIFEuY3VycmVudCwgdSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBfcihlLCByKSB7XG4gICAgICAgIHZhciBhID0gamUoZS50eXBlLCByLCBlLnJlZiwgZS5fc2VsZiwgZS5fc291cmNlLCBlLl9vd25lciwgZS5wcm9wcyk7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYnIoZSwgciwgYSkge1xuICAgICAgICBpZiAoZSA9PSBudWxsKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlYWN0LmNsb25lRWxlbWVudCguLi4pOiBUaGUgYXJndW1lbnQgbXVzdCBiZSBhIFJlYWN0IGVsZW1lbnQsIGJ1dCB5b3UgcGFzc2VkIFwiICsgZSArIFwiLlwiKTtcbiAgICAgICAgdmFyIG8sIHUgPSBoKHt9LCBlLnByb3BzKSwgcCA9IGUua2V5LCBsID0gZS5yZWYsIHkgPSBlLl9zZWxmLCBFID0gZS5fc291cmNlLCBPID0gZS5fb3duZXI7XG4gICAgICAgIGlmIChyICE9IG51bGwpIHtcbiAgICAgICAgICBZZShyKSAmJiAobCA9IHIucmVmLCBPID0gUS5jdXJyZW50KSwgZ2UocikgJiYgKE9lKHIua2V5KSwgcCA9IFwiXCIgKyByLmtleSk7XG4gICAgICAgICAgdmFyIEE7XG4gICAgICAgICAgZS50eXBlICYmIGUudHlwZS5kZWZhdWx0UHJvcHMgJiYgKEEgPSBlLnR5cGUuZGVmYXVsdFByb3BzKTtcbiAgICAgICAgICBmb3IgKG8gaW4gcilcbiAgICAgICAgICAgIGtlLmNhbGwociwgbykgJiYgIUxlLmhhc093blByb3BlcnR5KG8pICYmIChyW29dID09PSB2b2lkIDAgJiYgQSAhPT0gdm9pZCAwID8gdVtvXSA9IEFbb10gOiB1W29dID0gcltvXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgICAgICAgaWYgKHggPT09IDEpXG4gICAgICAgICAgdS5jaGlsZHJlbiA9IGE7XG4gICAgICAgIGVsc2UgaWYgKHggPiAxKSB7XG4gICAgICAgICAgZm9yICh2YXIgJCA9IEFycmF5KHgpLCBNID0gMDsgTSA8IHg7IE0rKylcbiAgICAgICAgICAgICRbTV0gPSBhcmd1bWVudHNbTSArIDJdO1xuICAgICAgICAgIHUuY2hpbGRyZW4gPSAkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqZShlLnR5cGUsIHAsIGwsIHksIEUsIE8sIHUpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gX2UoZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGUgPT0gXCJvYmplY3RcIiAmJiBlICE9PSBudWxsICYmIGUuJCR0eXBlb2YgPT09IEc7XG4gICAgICB9XG4gICAgICB2YXIgdHIgPSBcIi5cIiwgRXIgPSBcIjpcIjtcbiAgICAgIGZ1bmN0aW9uIFJyKGUpIHtcbiAgICAgICAgdmFyIHIgPSAvWz06XS9nLCBhID0ge1xuICAgICAgICAgIFwiPVwiOiBcIj0wXCIsXG4gICAgICAgICAgXCI6XCI6IFwiPTJcIlxuICAgICAgICB9LCBvID0gZS5yZXBsYWNlKHIsIGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgICByZXR1cm4gYVt1XTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBcIiRcIiArIG87XG4gICAgICB9XG4gICAgICB2YXIgTmUgPSAhMSwgbnIgPSAvXFwvKy9nO1xuICAgICAgZnVuY3Rpb24geWUoZSkge1xuICAgICAgICByZXR1cm4gZS5yZXBsYWNlKG5yLCBcIiQmL1wiKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIEFlKGUsIHIpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBlID09IFwib2JqZWN0XCIgJiYgZSAhPT0gbnVsbCAmJiBlLmtleSAhPSBudWxsID8gKE9lKGUua2V5KSwgUnIoXCJcIiArIGUua2V5KSkgOiByLnRvU3RyaW5nKDM2KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGJlKGUsIHIsIGEsIG8sIHUpIHtcbiAgICAgICAgdmFyIHAgPSB0eXBlb2YgZTtcbiAgICAgICAgKHAgPT09IFwidW5kZWZpbmVkXCIgfHwgcCA9PT0gXCJib29sZWFuXCIpICYmIChlID0gbnVsbCk7XG4gICAgICAgIHZhciBsID0gITE7XG4gICAgICAgIGlmIChlID09PSBudWxsKVxuICAgICAgICAgIGwgPSAhMDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHN3aXRjaCAocCkge1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgICBsID0gITA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgICBzd2l0Y2ggKGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEc6XG4gICAgICAgICAgICAgICAgY2FzZSBuZTpcbiAgICAgICAgICAgICAgICAgIGwgPSAhMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgaWYgKGwpIHtcbiAgICAgICAgICB2YXIgeSA9IGUsIEUgPSB1KHkpLCBPID0gbyA9PT0gXCJcIiA/IHRyICsgQWUoeSwgMCkgOiBvO1xuICAgICAgICAgIGlmIChGZShFKSkge1xuICAgICAgICAgICAgdmFyIEEgPSBcIlwiO1xuICAgICAgICAgICAgTyAhPSBudWxsICYmIChBID0geWUoTykgKyBcIi9cIiksIGJlKEUsIHIsIEEsIFwiXCIsIGZ1bmN0aW9uKFZ0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBWdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgRSAhPSBudWxsICYmIChfZShFKSAmJiAoRS5rZXkgJiYgKCF5IHx8IHkua2V5ICE9PSBFLmtleSkgJiYgT2UoRS5rZXkpLCBFID0gX3IoXG4gICAgICAgICAgICAgIEUsXG4gICAgICAgICAgICAgIC8vIEtlZXAgYm90aCB0aGUgKG1hcHBlZCkgYW5kIG9sZCBrZXlzIGlmIHRoZXkgZGlmZmVyLCBqdXN0IGFzXG4gICAgICAgICAgICAgIC8vIHRyYXZlcnNlQWxsQ2hpbGRyZW4gdXNlZCB0byBkbyBmb3Igb2JqZWN0cyBhcyBjaGlsZHJlblxuICAgICAgICAgICAgICBhICsgLy8gJEZsb3dGaXhNZSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBSZWFjdC5Qb3J0YWwgZG9lc24ndCBoYXZlIGEga2V5XG4gICAgICAgICAgICAgIChFLmtleSAmJiAoIXkgfHwgeS5rZXkgIT09IEUua2V5KSA/IChcbiAgICAgICAgICAgICAgICAvLyAkRmxvd0ZpeE1lIEZsb3cgaW5jb3JyZWN0bHkgdGhpbmtzIGV4aXN0aW5nIGVsZW1lbnQncyBrZXkgY2FuIGJlIGEgbnVtYmVyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gICAgICAgICAgICAgICAgeWUoXCJcIiArIEUua2V5KSArIFwiL1wiXG4gICAgICAgICAgICAgICkgOiBcIlwiKSArIE9cbiAgICAgICAgICAgICkpLCByLnB1c2goRSkpO1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHZhciB4LCAkLCBNID0gMCwgcSA9IG8gPT09IFwiXCIgPyB0ciA6IG8gKyBFcjtcbiAgICAgICAgaWYgKEZlKGUpKVxuICAgICAgICAgIGZvciAodmFyIHZyID0gMDsgdnIgPCBlLmxlbmd0aDsgdnIrKylcbiAgICAgICAgICAgIHggPSBlW3ZyXSwgJCA9IHEgKyBBZSh4LCB2ciksIE0gKz0gYmUoeCwgciwgYSwgJCwgdSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciAkciA9IEwoZSk7XG4gICAgICAgICAgaWYgKHR5cGVvZiAkciA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHZhciBpdCA9IGU7XG4gICAgICAgICAgICAkciA9PT0gaXQuZW50cmllcyAmJiAoTmUgfHwgdWUoXCJVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCBzdXBwb3J0ZWQuIFVzZSBhbiBhcnJheSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuXCIpLCBOZSA9ICEwKTtcbiAgICAgICAgICAgIGZvciAodmFyICR0ID0gJHIuY2FsbChpdCksIHV0LCBMdCA9IDA7ICEodXQgPSAkdC5uZXh0KCkpLmRvbmU7IClcbiAgICAgICAgICAgICAgeCA9IHV0LnZhbHVlLCAkID0gcSArIEFlKHgsIEx0KyspLCBNICs9IGJlKHgsIHIsIGEsICQsIHUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgdmFyIHN0ID0gU3RyaW5nKGUpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiBcIiArIChzdCA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIiA/IFwib2JqZWN0IHdpdGgga2V5cyB7XCIgKyBPYmplY3Qua2V5cyhlKS5qb2luKFwiLCBcIikgKyBcIn1cIiA6IHN0KSArIFwiKS4gSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE07XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB4ZShlLCByLCBhKSB7XG4gICAgICAgIGlmIChlID09IG51bGwpXG4gICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIHZhciBvID0gW10sIHUgPSAwO1xuICAgICAgICByZXR1cm4gYmUoZSwgbywgXCJcIiwgXCJcIiwgZnVuY3Rpb24ocCkge1xuICAgICAgICAgIHJldHVybiByLmNhbGwoYSwgcCwgdSsrKTtcbiAgICAgICAgfSksIG87XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBDcihlKSB7XG4gICAgICAgIHZhciByID0gMDtcbiAgICAgICAgcmV0dXJuIHhlKGUsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHIrKztcbiAgICAgICAgfSksIHI7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBhcihlLCByLCBhKSB7XG4gICAgICAgIHhlKGUsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSwgYSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB3cihlKSB7XG4gICAgICAgIHJldHVybiB4ZShlLCBmdW5jdGlvbihyKSB7XG4gICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH0pIHx8IFtdO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gb3IoZSkge1xuICAgICAgICBpZiAoIV9lKGUpKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlYWN0LkNoaWxkcmVuLm9ubHkgZXhwZWN0ZWQgdG8gcmVjZWl2ZSBhIHNpbmdsZSBSZWFjdCBlbGVtZW50IGNoaWxkLlwiKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBpcihlKSB7XG4gICAgICAgIHZhciByID0ge1xuICAgICAgICAgICQkdHlwZW9mOiBKLFxuICAgICAgICAgIC8vIEFzIGEgd29ya2Fyb3VuZCB0byBzdXBwb3J0IG11bHRpcGxlIGNvbmN1cnJlbnQgcmVuZGVyZXJzLCB3ZSBjYXRlZ29yaXplXG4gICAgICAgICAgLy8gc29tZSByZW5kZXJlcnMgYXMgcHJpbWFyeSBhbmQgb3RoZXJzIGFzIHNlY29uZGFyeS4gV2Ugb25seSBleHBlY3RcbiAgICAgICAgICAvLyB0aGVyZSB0byBiZSB0d28gY29uY3VycmVudCByZW5kZXJlcnMgYXQgbW9zdDogUmVhY3QgTmF0aXZlIChwcmltYXJ5KSBhbmRcbiAgICAgICAgICAvLyBGYWJyaWMgKHNlY29uZGFyeSk7IFJlYWN0IERPTSAocHJpbWFyeSkgYW5kIFJlYWN0IEFSVCAoc2Vjb25kYXJ5KS5cbiAgICAgICAgICAvLyBTZWNvbmRhcnkgcmVuZGVyZXJzIHN0b3JlIHRoZWlyIGNvbnRleHQgdmFsdWVzIG9uIHNlcGFyYXRlIGZpZWxkcy5cbiAgICAgICAgICBfY3VycmVudFZhbHVlOiBlLFxuICAgICAgICAgIF9jdXJyZW50VmFsdWUyOiBlLFxuICAgICAgICAgIC8vIFVzZWQgdG8gdHJhY2sgaG93IG1hbnkgY29uY3VycmVudCByZW5kZXJlcnMgdGhpcyBjb250ZXh0IGN1cnJlbnRseVxuICAgICAgICAgIC8vIHN1cHBvcnRzIHdpdGhpbiBpbiBhIHNpbmdsZSByZW5kZXJlci4gU3VjaCBhcyBwYXJhbGxlbCBzZXJ2ZXIgcmVuZGVyaW5nLlxuICAgICAgICAgIF90aHJlYWRDb3VudDogMCxcbiAgICAgICAgICAvLyBUaGVzZSBhcmUgY2lyY3VsYXJcbiAgICAgICAgICBQcm92aWRlcjogbnVsbCxcbiAgICAgICAgICBDb25zdW1lcjogbnVsbCxcbiAgICAgICAgICAvLyBBZGQgdGhlc2UgdG8gdXNlIHNhbWUgaGlkZGVuIGNsYXNzIGluIFZNIGFzIFNlcnZlckNvbnRleHRcbiAgICAgICAgICBfZGVmYXVsdFZhbHVlOiBudWxsLFxuICAgICAgICAgIF9nbG9iYWxOYW1lOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHIuUHJvdmlkZXIgPSB7XG4gICAgICAgICAgJCR0eXBlb2Y6IEQsXG4gICAgICAgICAgX2NvbnRleHQ6IHJcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGEgPSAhMSwgbyA9ICExLCB1ID0gITE7XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgcCA9IHtcbiAgICAgICAgICAgICQkdHlwZW9mOiBKLFxuICAgICAgICAgICAgX2NvbnRleHQ6IHJcbiAgICAgICAgICB9O1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHAsIHtcbiAgICAgICAgICAgIFByb3ZpZGVyOiB7XG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG8gfHwgKG8gPSAhMCwgZChcIlJlbmRlcmluZyA8Q29udGV4dC5Db25zdW1lci5Qcm92aWRlcj4gaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuUHJvdmlkZXI+IGluc3RlYWQ/XCIpKSwgci5Qcm92aWRlcjtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbihsKSB7XG4gICAgICAgICAgICAgICAgci5Qcm92aWRlciA9IGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfY3VycmVudFZhbHVlOiB7XG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHIuX2N1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbihsKSB7XG4gICAgICAgICAgICAgICAgci5fY3VycmVudFZhbHVlID0gbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9jdXJyZW50VmFsdWUyOiB7XG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHIuX2N1cnJlbnRWYWx1ZTI7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24obCkge1xuICAgICAgICAgICAgICAgIHIuX2N1cnJlbnRWYWx1ZTIgPSBsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3RocmVhZENvdW50OiB7XG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHIuX3RocmVhZENvdW50O1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgICAgICAgICByLl90aHJlYWRDb3VudCA9IGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBDb25zdW1lcjoge1xuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhIHx8IChhID0gITAsIGQoXCJSZW5kZXJpbmcgPENvbnRleHQuQ29uc3VtZXIuQ29uc3VtZXI+IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gcmVuZGVyIDxDb250ZXh0LkNvbnN1bWVyPiBpbnN0ZWFkP1wiKSksIHIuQ29uc3VtZXI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaXNwbGF5TmFtZToge1xuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByLmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgICAgICAgICB1IHx8ICh1ZShcIlNldHRpbmcgYGRpc3BsYXlOYW1lYCBvbiBDb250ZXh0LkNvbnN1bWVyIGhhcyBubyBlZmZlY3QuIFlvdSBzaG91bGQgc2V0IGl0IGRpcmVjdGx5IG9uIHRoZSBjb250ZXh0IHdpdGggQ29udGV4dC5kaXNwbGF5TmFtZSA9ICclcycuXCIsIGwpLCB1ID0gITApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksIHIuQ29uc3VtZXIgPSBwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByLl9jdXJyZW50UmVuZGVyZXIgPSBudWxsLCByLl9jdXJyZW50UmVuZGVyZXIyID0gbnVsbCwgcjtcbiAgICAgIH1cbiAgICAgIHZhciBEZSA9IC0xLCBCZSA9IDAsIHplID0gMSwgU3IgPSAyO1xuICAgICAgZnVuY3Rpb24gVHIoZSkge1xuICAgICAgICBpZiAoZS5fc3RhdHVzID09PSBEZSkge1xuICAgICAgICAgIHZhciByID0gZS5fcmVzdWx0LCBhID0gcigpO1xuICAgICAgICAgIGlmIChhLnRoZW4oZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgaWYgKGUuX3N0YXR1cyA9PT0gQmUgfHwgZS5fc3RhdHVzID09PSBEZSkge1xuICAgICAgICAgICAgICB2YXIgbCA9IGU7XG4gICAgICAgICAgICAgIGwuX3N0YXR1cyA9IHplLCBsLl9yZXN1bHQgPSBwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgIGlmIChlLl9zdGF0dXMgPT09IEJlIHx8IGUuX3N0YXR1cyA9PT0gRGUpIHtcbiAgICAgICAgICAgICAgdmFyIGwgPSBlO1xuICAgICAgICAgICAgICBsLl9zdGF0dXMgPSBTciwgbC5fcmVzdWx0ID0gcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSwgZS5fc3RhdHVzID09PSBEZSkge1xuICAgICAgICAgICAgdmFyIG8gPSBlO1xuICAgICAgICAgICAgby5fc3RhdHVzID0gQmUsIG8uX3Jlc3VsdCA9IGE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlLl9zdGF0dXMgPT09IHplKSB7XG4gICAgICAgICAgdmFyIHUgPSBlLl9yZXN1bHQ7XG4gICAgICAgICAgcmV0dXJuIHUgPT09IHZvaWQgMCAmJiBkKGBsYXp5OiBFeHBlY3RlZCB0aGUgcmVzdWx0IG9mIGEgZHluYW1pYyBpbXBvcnQoKSBjYWxsLiBJbnN0ZWFkIHJlY2VpdmVkOiAlc1xuXG5Zb3VyIGNvZGUgc2hvdWxkIGxvb2sgbGlrZTogXG4gIGNvbnN0IE15Q29tcG9uZW50ID0gbGF6eSgoKSA9PiBpbXBvcnQoJy4vTXlDb21wb25lbnQnKSlcblxuRGlkIHlvdSBhY2NpZGVudGFsbHkgcHV0IGN1cmx5IGJyYWNlcyBhcm91bmQgdGhlIGltcG9ydD9gLCB1KSwgXCJkZWZhdWx0XCIgaW4gdSB8fCBkKGBsYXp5OiBFeHBlY3RlZCB0aGUgcmVzdWx0IG9mIGEgZHluYW1pYyBpbXBvcnQoKSBjYWxsLiBJbnN0ZWFkIHJlY2VpdmVkOiAlc1xuXG5Zb3VyIGNvZGUgc2hvdWxkIGxvb2sgbGlrZTogXG4gIGNvbnN0IE15Q29tcG9uZW50ID0gbGF6eSgoKSA9PiBpbXBvcnQoJy4vTXlDb21wb25lbnQnKSlgLCB1KSwgdS5kZWZhdWx0O1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICB0aHJvdyBlLl9yZXN1bHQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBPcihlKSB7XG4gICAgICAgIHZhciByID0ge1xuICAgICAgICAgIC8vIFdlIHVzZSB0aGVzZSBmaWVsZHMgdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAgICAgICAgICBfc3RhdHVzOiBEZSxcbiAgICAgICAgICBfcmVzdWx0OiBlXG4gICAgICAgIH0sIGEgPSB7XG4gICAgICAgICAgJCR0eXBlb2Y6IGZlLFxuICAgICAgICAgIF9wYXlsb2FkOiByLFxuICAgICAgICAgIF9pbml0OiBUclxuICAgICAgICB9O1xuICAgICAgICB7XG4gICAgICAgICAgdmFyIG8sIHU7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoYSwge1xuICAgICAgICAgICAgZGVmYXVsdFByb3BzOiB7XG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgICAgIGQoXCJSZWFjdC5sYXp5KC4uLik6IEl0IGlzIG5vdCBzdXBwb3J0ZWQgdG8gYXNzaWduIGBkZWZhdWx0UHJvcHNgIHRvIGEgbGF6eSBjb21wb25lbnQgaW1wb3J0LiBFaXRoZXIgc3BlY2lmeSB0aGVtIHdoZXJlIHRoZSBjb21wb25lbnQgaXMgZGVmaW5lZCwgb3IgY3JlYXRlIGEgd3JhcHBpbmcgY29tcG9uZW50IGFyb3VuZCBpdC5cIiksIG8gPSBwLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoYSwgXCJkZWZhdWx0UHJvcHNcIiwge1xuICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb3BUeXBlczoge1xuICAgICAgICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1O1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgICAgICBkKFwiUmVhY3QubGF6eSguLi4pOiBJdCBpcyBub3Qgc3VwcG9ydGVkIHRvIGFzc2lnbiBgcHJvcFR5cGVzYCB0byBhIGxhenkgY29tcG9uZW50IGltcG9ydC4gRWl0aGVyIHNwZWNpZnkgdGhlbSB3aGVyZSB0aGUgY29tcG9uZW50IGlzIGRlZmluZWQsIG9yIGNyZWF0ZSBhIHdyYXBwaW5nIGNvbXBvbmVudCBhcm91bmQgaXQuXCIpLCB1ID0gcCwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGEsIFwicHJvcFR5cGVzXCIsIHtcbiAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIFByKGUpIHtcbiAgICAgICAgZSAhPSBudWxsICYmIGUuJCR0eXBlb2YgPT09IGsgPyBkKFwiZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgcmVjZWl2ZWQgYSBgbWVtb2AgY29tcG9uZW50LiBJbnN0ZWFkIG9mIGZvcndhcmRSZWYobWVtbyguLi4pKSwgdXNlIG1lbW8oZm9yd2FyZFJlZiguLi4pKS5cIikgOiB0eXBlb2YgZSAhPSBcImZ1bmN0aW9uXCIgPyBkKFwiZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgd2FzIGdpdmVuICVzLlwiLCBlID09PSBudWxsID8gXCJudWxsXCIgOiB0eXBlb2YgZSkgOiBlLmxlbmd0aCAhPT0gMCAmJiBlLmxlbmd0aCAhPT0gMiAmJiBkKFwiZm9yd2FyZFJlZiByZW5kZXIgZnVuY3Rpb25zIGFjY2VwdCBleGFjdGx5IHR3byBwYXJhbWV0ZXJzOiBwcm9wcyBhbmQgcmVmLiAlc1wiLCBlLmxlbmd0aCA9PT0gMSA/IFwiRGlkIHlvdSBmb3JnZXQgdG8gdXNlIHRoZSByZWYgcGFyYW1ldGVyP1wiIDogXCJBbnkgYWRkaXRpb25hbCBwYXJhbWV0ZXIgd2lsbCBiZSB1bmRlZmluZWQuXCIpLCBlICE9IG51bGwgJiYgKGUuZGVmYXVsdFByb3BzICE9IG51bGwgfHwgZS5wcm9wVHlwZXMgIT0gbnVsbCkgJiYgZChcImZvcndhcmRSZWYgcmVuZGVyIGZ1bmN0aW9ucyBkbyBub3Qgc3VwcG9ydCBwcm9wVHlwZXMgb3IgZGVmYXVsdFByb3BzLiBEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIGEgUmVhY3QgY29tcG9uZW50P1wiKTtcbiAgICAgICAgdmFyIHIgPSB7XG4gICAgICAgICAgJCR0eXBlb2Y6IEksXG4gICAgICAgICAgcmVuZGVyOiBlXG4gICAgICAgIH07XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgYTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkociwgXCJkaXNwbGF5TmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICAgICAgYSA9IG8sICFlLm5hbWUgJiYgIWUuZGlzcGxheU5hbWUgJiYgKGUuZGlzcGxheU5hbWUgPSBvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH1cbiAgICAgIHZhciB0O1xuICAgICAgdCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tb2R1bGUucmVmZXJlbmNlXCIpO1xuICAgICAgZnVuY3Rpb24gaShlKSB7XG4gICAgICAgIHJldHVybiAhISh0eXBlb2YgZSA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiB8fCBlID09PSBlZSB8fCBlID09PSBLIHx8IHJlIHx8IGUgPT09IEggfHwgZSA9PT0gVyB8fCBlID09PSBYIHx8IFogfHwgZSA9PT0gSWUgfHwgQ2UgfHwgVWUgfHwgd2UgfHwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiAmJiBlICE9PSBudWxsICYmIChlLiQkdHlwZW9mID09PSBmZSB8fCBlLiQkdHlwZW9mID09PSBrIHx8IGUuJCR0eXBlb2YgPT09IEQgfHwgZS4kJHR5cGVvZiA9PT0gSiB8fCBlLiQkdHlwZW9mID09PSBJIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAgICAgLy8gdHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBGbGlnaHQgY29uZmlndXJhdGlvbiBhbnl3aGVyZSBzaW5jZVxuICAgICAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAgICAgLy8gd2l0aC5cbiAgICAgICAgZS4kJHR5cGVvZiA9PT0gdCB8fCBlLmdldE1vZHVsZUlkICE9PSB2b2lkIDApKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGYoZSwgcikge1xuICAgICAgICBpKGUpIHx8IGQoXCJtZW1vOiBUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIGNvbXBvbmVudC4gSW5zdGVhZCByZWNlaXZlZDogJXNcIiwgZSA9PT0gbnVsbCA/IFwibnVsbFwiIDogdHlwZW9mIGUpO1xuICAgICAgICB2YXIgYSA9IHtcbiAgICAgICAgICAkJHR5cGVvZjogayxcbiAgICAgICAgICB0eXBlOiBlLFxuICAgICAgICAgIGNvbXBhcmU6IHIgPT09IHZvaWQgMCA/IG51bGwgOiByXG4gICAgICAgIH07XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbztcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYSwgXCJkaXNwbGF5TmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgICAgICAgbyA9IHUsICFlLm5hbWUgJiYgIWUuZGlzcGxheU5hbWUgJiYgKGUuZGlzcGxheU5hbWUgPSB1KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGMoKSB7XG4gICAgICAgIHZhciBlID0gaGUuY3VycmVudDtcbiAgICAgICAgcmV0dXJuIGUgPT09IG51bGwgJiYgZChgSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuIFRoaXMgY291bGQgaGFwcGVuIGZvciBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxuMS4gWW91IG1pZ2h0IGhhdmUgbWlzbWF0Y2hpbmcgdmVyc2lvbnMgb2YgUmVhY3QgYW5kIHRoZSByZW5kZXJlciAoc3VjaCBhcyBSZWFjdCBET00pXG4yLiBZb3UgbWlnaHQgYmUgYnJlYWtpbmcgdGhlIFJ1bGVzIG9mIEhvb2tzXG4zLiBZb3UgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QgaW4gdGhlIHNhbWUgYXBwXG5TZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2ludmFsaWQtaG9vay1jYWxsIGZvciB0aXBzIGFib3V0IGhvdyB0byBkZWJ1ZyBhbmQgZml4IHRoaXMgcHJvYmxlbS5gKSwgZTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIFIoZSkge1xuICAgICAgICB2YXIgciA9IGMoKTtcbiAgICAgICAgaWYgKGUuX2NvbnRleHQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHZhciBhID0gZS5fY29udGV4dDtcbiAgICAgICAgICBhLkNvbnN1bWVyID09PSBlID8gZChcIkNhbGxpbmcgdXNlQ29udGV4dChDb250ZXh0LkNvbnN1bWVyKSBpcyBub3Qgc3VwcG9ydGVkLCBtYXkgY2F1c2UgYnVncywgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gY2FsbCB1c2VDb250ZXh0KENvbnRleHQpIGluc3RlYWQ/XCIpIDogYS5Qcm92aWRlciA9PT0gZSAmJiBkKFwiQ2FsbGluZyB1c2VDb250ZXh0KENvbnRleHQuUHJvdmlkZXIpIGlzIG5vdCBzdXBwb3J0ZWQuIERpZCB5b3UgbWVhbiB0byBjYWxsIHVzZUNvbnRleHQoQ29udGV4dCkgaW5zdGVhZD9cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHIudXNlQ29udGV4dChlKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIFMoZSkge1xuICAgICAgICB2YXIgciA9IGMoKTtcbiAgICAgICAgcmV0dXJuIHIudXNlU3RhdGUoZSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBiKGUsIHIsIGEpIHtcbiAgICAgICAgdmFyIG8gPSBjKCk7XG4gICAgICAgIHJldHVybiBvLnVzZVJlZHVjZXIoZSwgciwgYSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBtKGUpIHtcbiAgICAgICAgdmFyIHIgPSBjKCk7XG4gICAgICAgIHJldHVybiByLnVzZVJlZihlKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHooZSwgcikge1xuICAgICAgICB2YXIgYSA9IGMoKTtcbiAgICAgICAgcmV0dXJuIGEudXNlRWZmZWN0KGUsIHIpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gRihlLCByKSB7XG4gICAgICAgIHZhciBhID0gYygpO1xuICAgICAgICByZXR1cm4gYS51c2VJbnNlcnRpb25FZmZlY3QoZSwgcik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBWKGUsIHIpIHtcbiAgICAgICAgdmFyIGEgPSBjKCk7XG4gICAgICAgIHJldHVybiBhLnVzZUxheW91dEVmZmVjdChlLCByKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHRlKGUsIHIpIHtcbiAgICAgICAgdmFyIGEgPSBjKCk7XG4gICAgICAgIHJldHVybiBhLnVzZUNhbGxiYWNrKGUsIHIpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gRWUoZSwgcikge1xuICAgICAgICB2YXIgYSA9IGMoKTtcbiAgICAgICAgcmV0dXJuIGEudXNlTWVtbyhlLCByKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHVyKGUsIHIsIGEpIHtcbiAgICAgICAgdmFyIG8gPSBjKCk7XG4gICAgICAgIHJldHVybiBvLnVzZUltcGVyYXRpdmVIYW5kbGUoZSwgciwgYSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBzZShlLCByKSB7XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgYSA9IGMoKTtcbiAgICAgICAgICByZXR1cm4gYS51c2VEZWJ1Z1ZhbHVlKGUsIHIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwdCgpIHtcbiAgICAgICAgdmFyIGUgPSBjKCk7XG4gICAgICAgIHJldHVybiBlLnVzZVRyYW5zaXRpb24oKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHZ0KGUpIHtcbiAgICAgICAgdmFyIHIgPSBjKCk7XG4gICAgICAgIHJldHVybiByLnVzZURlZmVycmVkVmFsdWUoZSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB5dCgpIHtcbiAgICAgICAgdmFyIGUgPSBjKCk7XG4gICAgICAgIHJldHVybiBlLnVzZUlkKCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBodChlLCByLCBhKSB7XG4gICAgICAgIHZhciBvID0gYygpO1xuICAgICAgICByZXR1cm4gby51c2VTeW5jRXh0ZXJuYWxTdG9yZShlLCByLCBhKTtcbiAgICAgIH1cbiAgICAgIHZhciBxZSA9IDAsIE1yLCBXciwgVXIsIFlyLCBCciwgenIsIHFyO1xuICAgICAgZnVuY3Rpb24gR3IoKSB7XG4gICAgICB9XG4gICAgICBHci5fX3JlYWN0RGlzYWJsZWRMb2cgPSAhMDtcbiAgICAgIGZ1bmN0aW9uIG10KCkge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKHFlID09PSAwKSB7XG4gICAgICAgICAgICBNciA9IGNvbnNvbGUubG9nLCBXciA9IGNvbnNvbGUuaW5mbywgVXIgPSBjb25zb2xlLndhcm4sIFlyID0gY29uc29sZS5lcnJvciwgQnIgPSBjb25zb2xlLmdyb3VwLCB6ciA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQsIHFyID0gY29uc29sZS5ncm91cEVuZDtcbiAgICAgICAgICAgIHZhciBlID0ge1xuICAgICAgICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgdmFsdWU6IEdyLFxuICAgICAgICAgICAgICB3cml0YWJsZTogITBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgICAgIGluZm86IGUsXG4gICAgICAgICAgICAgIGxvZzogZSxcbiAgICAgICAgICAgICAgd2FybjogZSxcbiAgICAgICAgICAgICAgZXJyb3I6IGUsXG4gICAgICAgICAgICAgIGdyb3VwOiBlLFxuICAgICAgICAgICAgICBncm91cENvbGxhcHNlZDogZSxcbiAgICAgICAgICAgICAgZ3JvdXBFbmQ6IGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBxZSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBndCgpIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmIChxZS0tLCBxZSA9PT0gMCkge1xuICAgICAgICAgICAgdmFyIGUgPSB7XG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICB3cml0YWJsZTogITBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgICAgIGxvZzogaCh7fSwgZSwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBNclxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgaW5mbzogaCh7fSwgZSwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBXclxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgd2FybjogaCh7fSwgZSwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBVclxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgZXJyb3I6IGgoe30sIGUsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogWXJcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIGdyb3VwOiBoKHt9LCBlLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IEJyXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBncm91cENvbGxhcHNlZDogaCh7fSwgZSwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB6clxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgZ3JvdXBFbmQ6IGgoe30sIGUsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogcXJcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBxZSA8IDAgJiYgZChcImRpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBrciA9IEIuUmVhY3RDdXJyZW50RGlzcGF0Y2hlciwganI7XG4gICAgICBmdW5jdGlvbiBzcihlLCByLCBhKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoanIgPT09IHZvaWQgMClcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICB9IGNhdGNoICh1KSB7XG4gICAgICAgICAgICAgIHZhciBvID0gdS5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgICAgICAganIgPSBvICYmIG9bMV0gfHwgXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYFxuYCArIGpyICsgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIEFyID0gITEsIGZyO1xuICAgICAge1xuICAgICAgICB2YXIgX3QgPSB0eXBlb2YgV2Vha01hcCA9PSBcImZ1bmN0aW9uXCIgPyBXZWFrTWFwIDogTWFwO1xuICAgICAgICBmciA9IG5ldyBfdCgpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gSHIoZSwgcikge1xuICAgICAgICBpZiAoIWUgfHwgQXIpXG4gICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgYSA9IGZyLmdldChlKTtcbiAgICAgICAgICBpZiAoYSAhPT0gdm9pZCAwKVxuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG87XG4gICAgICAgIEFyID0gITA7XG4gICAgICAgIHZhciB1ID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7XG4gICAgICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdm9pZCAwO1xuICAgICAgICB2YXIgcDtcbiAgICAgICAgcCA9IGtyLmN1cnJlbnQsIGtyLmN1cnJlbnQgPSBudWxsLCBtdCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgICB2YXIgbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkobC5wcm90b3R5cGUsIFwicHJvcHNcIiwge1xuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLCB0eXBlb2YgUmVmbGVjdCA9PSBcIm9iamVjdFwiICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QobCwgW10pO1xuICAgICAgICAgICAgICB9IGNhdGNoIChxKSB7XG4gICAgICAgICAgICAgICAgbyA9IHE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZSwgW10sIGwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsLmNhbGwoKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAocSkge1xuICAgICAgICAgICAgICAgIG8gPSBxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGUuY2FsbChsLnByb3RvdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChxKSB7XG4gICAgICAgICAgICAgIG8gPSBxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAocSkge1xuICAgICAgICAgIGlmIChxICYmIG8gJiYgdHlwZW9mIHEuc3RhY2sgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZm9yICh2YXIgeSA9IHEuc3RhY2suc3BsaXQoYFxuYCksIEUgPSBvLnN0YWNrLnNwbGl0KGBcbmApLCBPID0geS5sZW5ndGggLSAxLCBBID0gRS5sZW5ndGggLSAxOyBPID49IDEgJiYgQSA+PSAwICYmIHlbT10gIT09IEVbQV07IClcbiAgICAgICAgICAgICAgQS0tO1xuICAgICAgICAgICAgZm9yICg7IE8gPj0gMSAmJiBBID49IDA7IE8tLSwgQS0tKVxuICAgICAgICAgICAgICBpZiAoeVtPXSAhPT0gRVtBXSkge1xuICAgICAgICAgICAgICAgIGlmIChPICE9PSAxIHx8IEEgIT09IDEpXG4gICAgICAgICAgICAgICAgICBkb1xuICAgICAgICAgICAgICAgICAgICBpZiAoTy0tLCBBLS0sIEEgPCAwIHx8IHlbT10gIT09IEVbQV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IGBcbmAgKyB5W09dLnJlcGxhY2UoXCIgYXQgbmV3IFwiLCBcIiBhdCBcIik7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuZGlzcGxheU5hbWUgJiYgeC5pbmNsdWRlcyhcIjxhbm9ueW1vdXM+XCIpICYmICh4ID0geC5yZXBsYWNlKFwiPGFub255bW91cz5cIiwgZS5kaXNwbGF5TmFtZSkpLCB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgJiYgZnIuc2V0KGUsIHgpLCB4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoTyA+PSAxICYmIEEgPj0gMCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgQXIgPSAhMSwga3IuY3VycmVudCA9IHAsIGd0KCksIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgJCA9IGUgPyBlLmRpc3BsYXlOYW1lIHx8IGUubmFtZSA6IFwiXCIsIE0gPSAkID8gc3IoJCkgOiBcIlwiO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiICYmIGZyLnNldChlLCBNKSwgTTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGJ0KGUsIHIsIGEpIHtcbiAgICAgICAgcmV0dXJuIEhyKGUsICExKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIEV0KGUpIHtcbiAgICAgICAgdmFyIHIgPSBlLnByb3RvdHlwZTtcbiAgICAgICAgcmV0dXJuICEhKHIgJiYgci5pc1JlYWN0Q29tcG9uZW50KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGNyKGUsIHIsIGEpIHtcbiAgICAgICAgaWYgKGUgPT0gbnVsbClcbiAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgaWYgKHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICByZXR1cm4gSHIoZSwgRXQoZSkpO1xuICAgICAgICBpZiAodHlwZW9mIGUgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICByZXR1cm4gc3IoZSk7XG4gICAgICAgIHN3aXRjaCAoZSkge1xuICAgICAgICAgIGNhc2UgVzpcbiAgICAgICAgICAgIHJldHVybiBzcihcIlN1c3BlbnNlXCIpO1xuICAgICAgICAgIGNhc2UgWDpcbiAgICAgICAgICAgIHJldHVybiBzcihcIlN1c3BlbnNlTGlzdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGUgPT0gXCJvYmplY3RcIilcbiAgICAgICAgICBzd2l0Y2ggKGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgIGNhc2UgSTpcbiAgICAgICAgICAgICAgcmV0dXJuIGJ0KGUucmVuZGVyKTtcbiAgICAgICAgICAgIGNhc2UgazpcbiAgICAgICAgICAgICAgcmV0dXJuIGNyKGUudHlwZSwgciwgYSk7XG4gICAgICAgICAgICBjYXNlIGZlOiB7XG4gICAgICAgICAgICAgIHZhciBvID0gZSwgdSA9IG8uX3BheWxvYWQsIHAgPSBvLl9pbml0O1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjcihwKHUpLCByLCBhKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgICAgdmFyIEtyID0ge30sIEpyID0gQi5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgICAgZnVuY3Rpb24gbHIoZSkge1xuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgIHZhciByID0gZS5fb3duZXIsIGEgPSBjcihlLnR5cGUsIGUuX3NvdXJjZSwgciA/IHIudHlwZSA6IG51bGwpO1xuICAgICAgICAgIEpyLnNldEV4dHJhU3RhY2tGcmFtZShhKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgSnIuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gUnQoZSwgciwgYSwgbywgdSkge1xuICAgICAgICB7XG4gICAgICAgICAgdmFyIHAgPSBGdW5jdGlvbi5jYWxsLmJpbmQoa2UpO1xuICAgICAgICAgIGZvciAodmFyIGwgaW4gZSlcbiAgICAgICAgICAgIGlmIChwKGUsIGwpKSB7XG4gICAgICAgICAgICAgIHZhciB5ID0gdm9pZCAwO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZVtsXSAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBFID0gRXJyb3IoKG8gfHwgXCJSZWFjdCBjbGFzc1wiKSArIFwiOiBcIiArIGEgKyBcIiB0eXBlIGBcIiArIGwgKyBcImAgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYFwiICsgdHlwZW9mIGVbbF0gKyBcImAuVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuXCIpO1xuICAgICAgICAgICAgICAgICAgdGhyb3cgRS5uYW1lID0gXCJJbnZhcmlhbnQgVmlvbGF0aW9uXCIsIEU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHkgPSBlW2xdKHIsIGwsIG8sIGEsIG51bGwsIFwiU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRURcIik7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKE8pIHtcbiAgICAgICAgICAgICAgICB5ID0gTztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB5ICYmICEoeSBpbnN0YW5jZW9mIEVycm9yKSAmJiAobHIodSksIGQoXCIlczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciBmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCBzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuXCIsIG8gfHwgXCJSZWFjdCBjbGFzc1wiLCBhLCBsLCB0eXBlb2YgeSksIGxyKG51bGwpKSwgeSBpbnN0YW5jZW9mIEVycm9yICYmICEoeS5tZXNzYWdlIGluIEtyKSAmJiAoS3JbeS5tZXNzYWdlXSA9ICEwLCBscih1KSwgZChcIkZhaWxlZCAlcyB0eXBlOiAlc1wiLCBhLCB5Lm1lc3NhZ2UpLCBscihudWxsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIE1lKGUpIHtcbiAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICB2YXIgciA9IGUuX293bmVyLCBhID0gY3IoZS50eXBlLCBlLl9zb3VyY2UsIHIgPyByLnR5cGUgOiBudWxsKTtcbiAgICAgICAgICBSZShhKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgUmUobnVsbCk7XG4gICAgICB9XG4gICAgICB2YXIgeHI7XG4gICAgICB4ciA9ICExO1xuICAgICAgZnVuY3Rpb24gWHIoKSB7XG4gICAgICAgIGlmIChRLmN1cnJlbnQpIHtcbiAgICAgICAgICB2YXIgZSA9IGRlKFEuY3VycmVudC50eXBlKTtcbiAgICAgICAgICBpZiAoZSlcbiAgICAgICAgICAgIHJldHVybiBgXG5cbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIFxcYGAgKyBlICsgXCJgLlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gQ3QoZSkge1xuICAgICAgICBpZiAoZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgdmFyIHIgPSBlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sIFwiXCIpLCBhID0gZS5saW5lTnVtYmVyO1xuICAgICAgICAgIHJldHVybiBgXG5cbkNoZWNrIHlvdXIgY29kZSBhdCBgICsgciArIFwiOlwiICsgYSArIFwiLlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gd3QoZSkge1xuICAgICAgICByZXR1cm4gZSAhPSBudWxsID8gQ3QoZS5fX3NvdXJjZSkgOiBcIlwiO1xuICAgICAgfVxuICAgICAgdmFyIFFyID0ge307XG4gICAgICBmdW5jdGlvbiBTdChlKSB7XG4gICAgICAgIHZhciByID0gWHIoKTtcbiAgICAgICAgaWYgKCFyKSB7XG4gICAgICAgICAgdmFyIGEgPSB0eXBlb2YgZSA9PSBcInN0cmluZ1wiID8gZSA6IGUuZGlzcGxheU5hbWUgfHwgZS5uYW1lO1xuICAgICAgICAgIGEgJiYgKHIgPSBgXG5cbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPGAgKyBhICsgXCI+LlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIFpyKGUsIHIpIHtcbiAgICAgICAgaWYgKCEoIWUuX3N0b3JlIHx8IGUuX3N0b3JlLnZhbGlkYXRlZCB8fCBlLmtleSAhPSBudWxsKSkge1xuICAgICAgICAgIGUuX3N0b3JlLnZhbGlkYXRlZCA9ICEwO1xuICAgICAgICAgIHZhciBhID0gU3Qocik7XG4gICAgICAgICAgaWYgKCFRclthXSkge1xuICAgICAgICAgICAgUXJbYV0gPSAhMDtcbiAgICAgICAgICAgIHZhciBvID0gXCJcIjtcbiAgICAgICAgICAgIGUgJiYgZS5fb3duZXIgJiYgZS5fb3duZXIgIT09IFEuY3VycmVudCAmJiAobyA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgZGUoZS5fb3duZXIudHlwZSkgKyBcIi5cIiksIE1lKGUpLCBkKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBhLCBvKSwgTWUobnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBldChlLCByKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgaWYgKEZlKGUpKVxuICAgICAgICAgICAgZm9yICh2YXIgYSA9IDA7IGEgPCBlLmxlbmd0aDsgYSsrKSB7XG4gICAgICAgICAgICAgIHZhciBvID0gZVthXTtcbiAgICAgICAgICAgICAgX2UobykgJiYgWnIobywgcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoX2UoZSkpXG4gICAgICAgICAgICBlLl9zdG9yZSAmJiAoZS5fc3RvcmUudmFsaWRhdGVkID0gITApO1xuICAgICAgICAgIGVsc2UgaWYgKGUpIHtcbiAgICAgICAgICAgIHZhciB1ID0gTChlKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdSA9PSBcImZ1bmN0aW9uXCIgJiYgdSAhPT0gZS5lbnRyaWVzKVxuICAgICAgICAgICAgICBmb3IgKHZhciBwID0gdS5jYWxsKGUpLCBsOyAhKGwgPSBwLm5leHQoKSkuZG9uZTsgKVxuICAgICAgICAgICAgICAgIF9lKGwudmFsdWUpICYmIFpyKGwudmFsdWUsIHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcnQoZSkge1xuICAgICAgICB7XG4gICAgICAgICAgdmFyIHIgPSBlLnR5cGU7XG4gICAgICAgICAgaWYgKHIgPT0gbnVsbCB8fCB0eXBlb2YgciA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIHZhciBhO1xuICAgICAgICAgIGlmICh0eXBlb2YgciA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICBhID0gci5wcm9wVHlwZXM7XG4gICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHIgPT0gXCJvYmplY3RcIiAmJiAoci4kJHR5cGVvZiA9PT0gSSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgICAgICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgICAgICAgci4kJHR5cGVvZiA9PT0gaykpXG4gICAgICAgICAgICBhID0gci5wcm9wVHlwZXM7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGlmIChhKSB7XG4gICAgICAgICAgICB2YXIgbyA9IGRlKHIpO1xuICAgICAgICAgICAgUnQoYSwgZS5wcm9wcywgXCJwcm9wXCIsIG8sIGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoci5Qcm9wVHlwZXMgIT09IHZvaWQgMCAmJiAheHIpIHtcbiAgICAgICAgICAgIHhyID0gITA7XG4gICAgICAgICAgICB2YXIgdSA9IGRlKHIpO1xuICAgICAgICAgICAgZChcIkNvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50P1wiLCB1IHx8IFwiVW5rbm93blwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHlwZW9mIHIuZ2V0RGVmYXVsdFByb3BzID09IFwiZnVuY3Rpb25cIiAmJiAhci5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQgJiYgZChcImdldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyBkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBUdChlKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBmb3IgKHZhciByID0gT2JqZWN0LmtleXMoZS5wcm9wcyksIGEgPSAwOyBhIDwgci5sZW5ndGg7IGErKykge1xuICAgICAgICAgICAgdmFyIG8gPSByW2FdO1xuICAgICAgICAgICAgaWYgKG8gIT09IFwiY2hpbGRyZW5cIiAmJiBvICE9PSBcImtleVwiKSB7XG4gICAgICAgICAgICAgIE1lKGUpLCBkKFwiSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy5cIiwgbyksIE1lKG51bGwpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZS5yZWYgIT09IG51bGwgJiYgKE1lKGUpLCBkKFwiSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC5cIiksIE1lKG51bGwpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdHQoZSwgciwgYSkge1xuICAgICAgICB2YXIgbyA9IGkoZSk7XG4gICAgICAgIGlmICghbykge1xuICAgICAgICAgIHZhciB1ID0gXCJcIjtcbiAgICAgICAgICAoZSA9PT0gdm9pZCAwIHx8IHR5cGVvZiBlID09IFwib2JqZWN0XCIgJiYgZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyhlKS5sZW5ndGggPT09IDApICYmICh1ICs9IFwiIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlIGl0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIik7XG4gICAgICAgICAgdmFyIHAgPSB3dChyKTtcbiAgICAgICAgICBwID8gdSArPSBwIDogdSArPSBYcigpO1xuICAgICAgICAgIHZhciBsO1xuICAgICAgICAgIGUgPT09IG51bGwgPyBsID0gXCJudWxsXCIgOiBGZShlKSA/IGwgPSBcImFycmF5XCIgOiBlICE9PSB2b2lkIDAgJiYgZS4kJHR5cGVvZiA9PT0gRyA/IChsID0gXCI8XCIgKyAoZGUoZS50eXBlKSB8fCBcIlVua25vd25cIikgKyBcIiAvPlwiLCB1ID0gXCIgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD9cIikgOiBsID0gdHlwZW9mIGUsIGQoXCJSZWFjdC5jcmVhdGVFbGVtZW50OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciBidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzXCIsIGwsIHUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB5ID0gZ3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHkgPT0gbnVsbClcbiAgICAgICAgICByZXR1cm4geTtcbiAgICAgICAgaWYgKG8pXG4gICAgICAgICAgZm9yICh2YXIgRSA9IDI7IEUgPCBhcmd1bWVudHMubGVuZ3RoOyBFKyspXG4gICAgICAgICAgICBldChhcmd1bWVudHNbRV0sIGUpO1xuICAgICAgICByZXR1cm4gZSA9PT0gZWUgPyBUdCh5KSA6IHJ0KHkpLCB5O1xuICAgICAgfVxuICAgICAgdmFyIG50ID0gITE7XG4gICAgICBmdW5jdGlvbiBPdChlKSB7XG4gICAgICAgIHZhciByID0gdHQuYmluZChudWxsLCBlKTtcbiAgICAgICAgcmV0dXJuIHIudHlwZSA9IGUsIG50IHx8IChudCA9ICEwLCB1ZShcIlJlYWN0LmNyZWF0ZUZhY3RvcnkoKSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gQ29uc2lkZXIgdXNpbmcgSlNYIG9yIHVzZSBSZWFjdC5jcmVhdGVFbGVtZW50KCkgZGlyZWN0bHkgaW5zdGVhZC5cIikpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkociwgXCJ0eXBlXCIsIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHVlKFwiRmFjdG9yeS50eXBlIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB0aGUgY2xhc3MgZGlyZWN0bHkgYmVmb3JlIHBhc3NpbmcgaXQgdG8gY3JlYXRlRmFjdG9yeS5cIiksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInR5cGVcIiwge1xuICAgICAgICAgICAgICB2YWx1ZTogZVxuICAgICAgICAgICAgfSksIGU7XG4gICAgICAgICAgfVxuICAgICAgICB9KSwgcjtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIFB0KGUsIHIsIGEpIHtcbiAgICAgICAgZm9yICh2YXIgbyA9IGJyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHUgPSAyOyB1IDwgYXJndW1lbnRzLmxlbmd0aDsgdSsrKVxuICAgICAgICAgIGV0KGFyZ3VtZW50c1t1XSwgby50eXBlKTtcbiAgICAgICAgcmV0dXJuIHJ0KG8pLCBvO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24ga3QoZSwgcikge1xuICAgICAgICB2YXIgYSA9IGllLnRyYW5zaXRpb247XG4gICAgICAgIGllLnRyYW5zaXRpb24gPSB7fTtcbiAgICAgICAgdmFyIG8gPSBpZS50cmFuc2l0aW9uO1xuICAgICAgICBpZS50cmFuc2l0aW9uLl91cGRhdGVkRmliZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBlKCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKGllLnRyYW5zaXRpb24gPSBhLCBhID09PSBudWxsICYmIG8uX3VwZGF0ZWRGaWJlcnMpIHtcbiAgICAgICAgICAgIHZhciB1ID0gby5fdXBkYXRlZEZpYmVycy5zaXplO1xuICAgICAgICAgICAgdSA+IDEwICYmIHVlKFwiRGV0ZWN0ZWQgYSBsYXJnZSBudW1iZXIgb2YgdXBkYXRlcyBpbnNpZGUgc3RhcnRUcmFuc2l0aW9uLiBJZiB0aGlzIGlzIGR1ZSB0byBhIHN1YnNjcmlwdGlvbiBwbGVhc2UgcmUtd3JpdGUgaXQgdG8gdXNlIFJlYWN0IHByb3ZpZGVkIGhvb2tzLiBPdGhlcndpc2UgY29uY3VycmVudCBtb2RlIGd1YXJhbnRlZXMgYXJlIG9mZiB0aGUgdGFibGUuXCIpLCBvLl91cGRhdGVkRmliZXJzLmNsZWFyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgYXQgPSAhMSwgZHIgPSBudWxsO1xuICAgICAgZnVuY3Rpb24ganQoZSkge1xuICAgICAgICBpZiAoZHIgPT09IG51bGwpXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciByID0gKFwicmVxdWlyZVwiICsgTWF0aC5yYW5kb20oKSkuc2xpY2UoMCwgNyksIGEgPSBZICYmIFlbcl07XG4gICAgICAgICAgICBkciA9IGEuY2FsbChZLCBcInRpbWVyc1wiKS5zZXRJbW1lZGlhdGU7XG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICBkciA9IGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgICAgICAgYXQgPT09ICExICYmIChhdCA9ICEwLCB0eXBlb2YgTWVzc2FnZUNoYW5uZWwgPiBcInVcIiAmJiBkKFwiVGhpcyBicm93c2VyIGRvZXMgbm90IGhhdmUgYSBNZXNzYWdlQ2hhbm5lbCBpbXBsZW1lbnRhdGlvbiwgc28gZW5xdWV1aW5nIHRhc2tzIHZpYSBhd2FpdCBhY3QoYXN5bmMgKCkgPT4gLi4uKSB3aWxsIGZhaWwuIFBsZWFzZSBmaWxlIGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMgaWYgeW91IGVuY291bnRlciB0aGlzIHdhcm5pbmcuXCIpKTtcbiAgICAgICAgICAgICAgdmFyIHAgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgICAgICAgcC5wb3J0MS5vbm1lc3NhZ2UgPSB1LCBwLnBvcnQyLnBvc3RNZXNzYWdlKHZvaWQgMCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRyKGUpO1xuICAgICAgfVxuICAgICAgdmFyIFdlID0gMCwgb3QgPSAhMTtcbiAgICAgIGZ1bmN0aW9uIEF0KGUpIHtcbiAgICAgICAge1xuICAgICAgICAgIHZhciByID0gV2U7XG4gICAgICAgICAgV2UrKywgTi5jdXJyZW50ID09PSBudWxsICYmIChOLmN1cnJlbnQgPSBbXSk7XG4gICAgICAgICAgdmFyIGEgPSBOLmlzQmF0Y2hpbmdMZWdhY3ksIG87XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChOLmlzQmF0Y2hpbmdMZWdhY3kgPSAhMCwgbyA9IGUoKSwgIWEgJiYgTi5kaWRTY2hlZHVsZUxlZ2FjeVVwZGF0ZSkge1xuICAgICAgICAgICAgICB2YXIgdSA9IE4uY3VycmVudDtcbiAgICAgICAgICAgICAgdSAhPT0gbnVsbCAmJiAoTi5kaWRTY2hlZHVsZUxlZ2FjeVVwZGF0ZSA9ICExLCBGcih1KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoJCkge1xuICAgICAgICAgICAgdGhyb3cgcHIociksICQ7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIE4uaXNCYXRjaGluZ0xlZ2FjeSA9IGE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvICE9PSBudWxsICYmIHR5cGVvZiBvID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG8udGhlbiA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHZhciBwID0gbywgbCA9ICExLCB5ID0ge1xuICAgICAgICAgICAgICB0aGVuOiBmdW5jdGlvbigkLCBNKSB7XG4gICAgICAgICAgICAgICAgbCA9ICEwLCBwLnRoZW4oZnVuY3Rpb24ocSkge1xuICAgICAgICAgICAgICAgICAgcHIociksIFdlID09PSAwID8gRHIocSwgJCwgTSkgOiAkKHEpO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKHEpIHtcbiAgICAgICAgICAgICAgICAgIHByKHIpLCBNKHEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuICFvdCAmJiB0eXBlb2YgUHJvbWlzZSA8IFwidVwiICYmIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBsIHx8IChvdCA9ICEwLCBkKFwiWW91IGNhbGxlZCBhY3QoYXN5bmMgKCkgPT4gLi4uKSB3aXRob3V0IGF3YWl0LiBUaGlzIGNvdWxkIGxlYWQgdG8gdW5leHBlY3RlZCB0ZXN0aW5nIGJlaGF2aW91ciwgaW50ZXJsZWF2aW5nIG11bHRpcGxlIGFjdCBjYWxscyBhbmQgbWl4aW5nIHRoZWlyIHNjb3Blcy4gWW91IHNob3VsZCAtIGF3YWl0IGFjdChhc3luYyAoKSA9PiAuLi4pO1wiKSk7XG4gICAgICAgICAgICB9KSwgeTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIEUgPSBvO1xuICAgICAgICAgICAgaWYgKHByKHIpLCBXZSA9PT0gMCkge1xuICAgICAgICAgICAgICB2YXIgTyA9IE4uY3VycmVudDtcbiAgICAgICAgICAgICAgTyAhPT0gbnVsbCAmJiAoRnIoTyksIE4uY3VycmVudCA9IG51bGwpO1xuICAgICAgICAgICAgICB2YXIgQSA9IHtcbiAgICAgICAgICAgICAgICB0aGVuOiBmdW5jdGlvbigkLCBNKSB7XG4gICAgICAgICAgICAgICAgICBOLmN1cnJlbnQgPT09IG51bGwgPyAoTi5jdXJyZW50ID0gW10sIERyKEUsICQsIE0pKSA6ICQoRSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICByZXR1cm4gQTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciB4ID0ge1xuICAgICAgICAgICAgICAgIHRoZW46IGZ1bmN0aW9uKCQsIE0pIHtcbiAgICAgICAgICAgICAgICAgICQoRSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHByKGUpIHtcbiAgICAgICAgZSAhPT0gV2UgLSAxICYmIGQoXCJZb3Ugc2VlbSB0byBoYXZlIG92ZXJsYXBwaW5nIGFjdCgpIGNhbGxzLCB0aGlzIGlzIG5vdCBzdXBwb3J0ZWQuIEJlIHN1cmUgdG8gYXdhaXQgcHJldmlvdXMgYWN0KCkgY2FsbHMgYmVmb3JlIG1ha2luZyBhIG5ldyBvbmUuIFwiKSwgV2UgPSBlO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gRHIoZSwgciwgYSkge1xuICAgICAgICB7XG4gICAgICAgICAgdmFyIG8gPSBOLmN1cnJlbnQ7XG4gICAgICAgICAgaWYgKG8gIT09IG51bGwpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBGcihvKSwganQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgby5sZW5ndGggPT09IDAgPyAoTi5jdXJyZW50ID0gbnVsbCwgcihlKSkgOiBEcihlLCByLCBhKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGNhdGNoICh1KSB7XG4gICAgICAgICAgICAgIGEodSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgcihlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIElyID0gITE7XG4gICAgICBmdW5jdGlvbiBGcihlKSB7XG4gICAgICAgIGlmICghSXIpIHtcbiAgICAgICAgICBJciA9ICEwO1xuICAgICAgICAgIHZhciByID0gMDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICg7IHIgPCBlLmxlbmd0aDsgcisrKSB7XG4gICAgICAgICAgICAgIHZhciBhID0gZVtyXTtcbiAgICAgICAgICAgICAgZG9cbiAgICAgICAgICAgICAgICBhID0gYSghMCk7XG4gICAgICAgICAgICAgIHdoaWxlIChhICE9PSBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGUubGVuZ3RoID0gMDtcbiAgICAgICAgICB9IGNhdGNoIChvKSB7XG4gICAgICAgICAgICB0aHJvdyBlID0gZS5zbGljZShyICsgMSksIG87XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIElyID0gITE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgeHQgPSB0dCwgRHQgPSBQdCwgSXQgPSBPdCwgRnQgPSB7XG4gICAgICAgIG1hcDogeGUsXG4gICAgICAgIGZvckVhY2g6IGFyLFxuICAgICAgICBjb3VudDogQ3IsXG4gICAgICAgIHRvQXJyYXk6IHdyLFxuICAgICAgICBvbmx5OiBvclxuICAgICAgfTtcbiAgICAgIHYuQ2hpbGRyZW4gPSBGdCwgdi5Db21wb25lbnQgPSBfLCB2LkZyYWdtZW50ID0gZWUsIHYuUHJvZmlsZXIgPSBLLCB2LlB1cmVDb21wb25lbnQgPSBVLCB2LlN0cmljdE1vZGUgPSBILCB2LlN1c3BlbnNlID0gVywgdi5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCA9IEIsIHYuY2xvbmVFbGVtZW50ID0gRHQsIHYuY3JlYXRlQ29udGV4dCA9IGlyLCB2LmNyZWF0ZUVsZW1lbnQgPSB4dCwgdi5jcmVhdGVGYWN0b3J5ID0gSXQsIHYuY3JlYXRlUmVmID0geXIsIHYuZm9yd2FyZFJlZiA9IFByLCB2LmlzVmFsaWRFbGVtZW50ID0gX2UsIHYubGF6eSA9IE9yLCB2Lm1lbW8gPSBmLCB2LnN0YXJ0VHJhbnNpdGlvbiA9IGt0LCB2LnVuc3RhYmxlX2FjdCA9IEF0LCB2LnVzZUNhbGxiYWNrID0gdGUsIHYudXNlQ29udGV4dCA9IFIsIHYudXNlRGVidWdWYWx1ZSA9IHNlLCB2LnVzZURlZmVycmVkVmFsdWUgPSB2dCwgdi51c2VFZmZlY3QgPSB6LCB2LnVzZUlkID0geXQsIHYudXNlSW1wZXJhdGl2ZUhhbmRsZSA9IHVyLCB2LnVzZUluc2VydGlvbkVmZmVjdCA9IEYsIHYudXNlTGF5b3V0RWZmZWN0ID0gViwgdi51c2VNZW1vID0gRWUsIHYudXNlUmVkdWNlciA9IGIsIHYudXNlUmVmID0gbSwgdi51c2VTdGF0ZSA9IFMsIHYudXNlU3luY0V4dGVybmFsU3RvcmUgPSBodCwgdi51c2VUcmFuc2l0aW9uID0gcHQsIHYudmVyc2lvbiA9IHBlLCB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fIDwgXCJ1XCIgJiYgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcCA9PSBcImZ1bmN0aW9uXCIgJiYgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wKG5ldyBFcnJvcigpKTtcbiAgICB9KCk7XG4gIH0oS2UsIEtlLmV4cG9ydHMpKSwgS2UuZXhwb3J0cztcbn1cbnByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IFZyLmV4cG9ydHMgPSBOdCgpIDogVnIuZXhwb3J0cyA9IE10KCk7XG52YXIgTnIgPSBWci5leHBvcnRzO1xuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xudmFyIGx0O1xuZnVuY3Rpb24gV3QoKSB7XG4gIGlmIChsdClcbiAgICByZXR1cm4gR2U7XG4gIGx0ID0gMTtcbiAgdmFyIFkgPSBOciwgdiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpLCBwZSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSwgRyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIG5lID0gWS5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRC5SZWFjdEN1cnJlbnRPd25lciwgZWUgPSB7IGtleTogITAsIHJlZjogITAsIF9fc2VsZjogITAsIF9fc291cmNlOiAhMCB9O1xuICBmdW5jdGlvbiBIKEssIEQsIEopIHtcbiAgICB2YXIgSSwgVyA9IHt9LCBYID0gbnVsbCwgayA9IG51bGw7XG4gICAgSiAhPT0gdm9pZCAwICYmIChYID0gXCJcIiArIEopLCBELmtleSAhPT0gdm9pZCAwICYmIChYID0gXCJcIiArIEQua2V5KSwgRC5yZWYgIT09IHZvaWQgMCAmJiAoayA9IEQucmVmKTtcbiAgICBmb3IgKEkgaW4gRClcbiAgICAgIEcuY2FsbChELCBJKSAmJiAhZWUuaGFzT3duUHJvcGVydHkoSSkgJiYgKFdbSV0gPSBEW0ldKTtcbiAgICBpZiAoSyAmJiBLLmRlZmF1bHRQcm9wcylcbiAgICAgIGZvciAoSSBpbiBEID0gSy5kZWZhdWx0UHJvcHMsIEQpXG4gICAgICAgIFdbSV0gPT09IHZvaWQgMCAmJiAoV1tJXSA9IERbSV0pO1xuICAgIHJldHVybiB7ICQkdHlwZW9mOiB2LCB0eXBlOiBLLCBrZXk6IFgsIHJlZjogaywgcHJvcHM6IFcsIF9vd25lcjogbmUuY3VycmVudCB9O1xuICB9XG4gIHJldHVybiBHZS5GcmFnbWVudCA9IHBlLCBHZS5qc3ggPSBILCBHZS5qc3hzID0gSCwgR2U7XG59XG52YXIgSGUgPSB7fTtcbi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbnZhciBkdDtcbmZ1bmN0aW9uIFV0KCkge1xuICByZXR1cm4gZHQgfHwgKGR0ID0gMSwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGZ1bmN0aW9uKCkge1xuICAgIHZhciBZID0gTnIsIHYgPSBTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSwgcGUgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLCBHID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLCBuZSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSwgZWUgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIiksIEggPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIiksIEsgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSwgRCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSwgSiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKSwgSSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpLCBXID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIiksIFggPSBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKSwgayA9IFN5bWJvbC5mb3IoXCJyZWFjdC5vZmZzY3JlZW5cIiksIGZlID0gU3ltYm9sLml0ZXJhdG9yLCBJZSA9IFwiQEBpdGVyYXRvclwiO1xuICAgIGZ1bmN0aW9uIGFlKHQpIHtcbiAgICAgIGlmICh0ID09PSBudWxsIHx8IHR5cGVvZiB0ICE9IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgdmFyIGkgPSBmZSAmJiB0W2ZlXSB8fCB0W0llXTtcbiAgICAgIHJldHVybiB0eXBlb2YgaSA9PSBcImZ1bmN0aW9uXCIgPyBpIDogbnVsbDtcbiAgICB9XG4gICAgdmFyIG9lID0gWS5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcbiAgICBmdW5jdGlvbiBMKHQpIHtcbiAgICAgIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGgsIGYgPSBuZXcgQXJyYXkoaSA+IDEgPyBpIC0gMSA6IDApLCBjID0gMTsgYyA8IGk7IGMrKylcbiAgICAgICAgICBmW2MgLSAxXSA9IGFyZ3VtZW50c1tjXTtcbiAgICAgICAgaGUoXCJlcnJvclwiLCB0LCBmKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaGUodCwgaSwgZikge1xuICAgICAge1xuICAgICAgICB2YXIgYyA9IG9lLlJlYWN0RGVidWdDdXJyZW50RnJhbWUsIFIgPSBjLmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgICAgICAgUiAhPT0gXCJcIiAmJiAoaSArPSBcIiVzXCIsIGYgPSBmLmNvbmNhdChbUl0pKTtcbiAgICAgICAgdmFyIFMgPSBmLm1hcChmdW5jdGlvbihiKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyhiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFMudW5zaGlmdChcIldhcm5pbmc6IFwiICsgaSksIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbdF0sIGNvbnNvbGUsIFMpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgaWUgPSAhMSwgTiA9ICExLCBRID0gITEsIGNlID0gITEsIHZlID0gITEsIFJlO1xuICAgIFJlID0gU3ltYm9sLmZvcihcInJlYWN0Lm1vZHVsZS5yZWZlcmVuY2VcIik7XG4gICAgZnVuY3Rpb24gQ2UodCkge1xuICAgICAgcmV0dXJuICEhKHR5cGVvZiB0ID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiIHx8IHQgPT09IEcgfHwgdCA9PT0gZWUgfHwgdmUgfHwgdCA9PT0gbmUgfHwgdCA9PT0gSiB8fCB0ID09PSBJIHx8IGNlIHx8IHQgPT09IGsgfHwgaWUgfHwgTiB8fCBRIHx8IHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdCAhPT0gbnVsbCAmJiAodC4kJHR5cGVvZiA9PT0gWCB8fCB0LiQkdHlwZW9mID09PSBXIHx8IHQuJCR0eXBlb2YgPT09IEggfHwgdC4kJHR5cGVvZiA9PT0gSyB8fCB0LiQkdHlwZW9mID09PSBEIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAgIC8vIHdlIGRvbid0IGtub3cgd2hpY2ggRmxpZ2h0IGJ1aWxkIHRoaXMgd2lsbCBlbmQgdXAgYmVpbmcgdXNlZFxuICAgICAgLy8gd2l0aC5cbiAgICAgIHQuJCR0eXBlb2YgPT09IFJlIHx8IHQuZ2V0TW9kdWxlSWQgIT09IHZvaWQgMCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBVZSh0LCBpLCBmKSB7XG4gICAgICB2YXIgYyA9IHQuZGlzcGxheU5hbWU7XG4gICAgICBpZiAoYylcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgICB2YXIgUiA9IGkuZGlzcGxheU5hbWUgfHwgaS5uYW1lIHx8IFwiXCI7XG4gICAgICByZXR1cm4gUiAhPT0gXCJcIiA/IGYgKyBcIihcIiArIFIgKyBcIilcIiA6IGY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdlKHQpIHtcbiAgICAgIHJldHVybiB0LmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBaKHQpIHtcbiAgICAgIGlmICh0ID09IG51bGwpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgaWYgKHR5cGVvZiB0LnRhZyA9PSBcIm51bWJlclwiICYmIEwoXCJSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiKSwgdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICByZXR1cm4gdC5kaXNwbGF5TmFtZSB8fCB0Lm5hbWUgfHwgbnVsbDtcbiAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKVxuICAgICAgICByZXR1cm4gdDtcbiAgICAgIHN3aXRjaCAodCkge1xuICAgICAgICBjYXNlIEc6XG4gICAgICAgICAgcmV0dXJuIFwiRnJhZ21lbnRcIjtcbiAgICAgICAgY2FzZSBwZTpcbiAgICAgICAgICByZXR1cm4gXCJQb3J0YWxcIjtcbiAgICAgICAgY2FzZSBlZTpcbiAgICAgICAgICByZXR1cm4gXCJQcm9maWxlclwiO1xuICAgICAgICBjYXNlIG5lOlxuICAgICAgICAgIHJldHVybiBcIlN0cmljdE1vZGVcIjtcbiAgICAgICAgY2FzZSBKOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgSTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdCA9PSBcIm9iamVjdFwiKVxuICAgICAgICBzd2l0Y2ggKHQuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIEs6XG4gICAgICAgICAgICB2YXIgaSA9IHQ7XG4gICAgICAgICAgICByZXR1cm4gd2UoaSkgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICAgIGNhc2UgSDpcbiAgICAgICAgICAgIHZhciBmID0gdDtcbiAgICAgICAgICAgIHJldHVybiB3ZShmLl9jb250ZXh0KSArIFwiLlByb3ZpZGVyXCI7XG4gICAgICAgICAgY2FzZSBEOlxuICAgICAgICAgICAgcmV0dXJuIFVlKHQsIHQucmVuZGVyLCBcIkZvcndhcmRSZWZcIik7XG4gICAgICAgICAgY2FzZSBXOlxuICAgICAgICAgICAgdmFyIGMgPSB0LmRpc3BsYXlOYW1lIHx8IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gYyAhPT0gbnVsbCA/IGMgOiBaKHQudHlwZSkgfHwgXCJNZW1vXCI7XG4gICAgICAgICAgY2FzZSBYOiB7XG4gICAgICAgICAgICB2YXIgUiA9IHQsIFMgPSBSLl9wYXlsb2FkLCBiID0gUi5faW5pdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBaKGIoUykpO1xuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciByZSA9IE9iamVjdC5hc3NpZ24sIEIgPSAwLCB1ZSwgZCwgbGUsIFNlLCBuLCBzLCBoO1xuICAgIGZ1bmN0aW9uIEMoKSB7XG4gICAgfVxuICAgIEMuX19yZWFjdERpc2FibGVkTG9nID0gITA7XG4gICAgZnVuY3Rpb24gXygpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKEIgPT09IDApIHtcbiAgICAgICAgICB1ZSA9IGNvbnNvbGUubG9nLCBkID0gY29uc29sZS5pbmZvLCBsZSA9IGNvbnNvbGUud2FybiwgU2UgPSBjb25zb2xlLmVycm9yLCBuID0gY29uc29sZS5ncm91cCwgcyA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQsIGggPSBjb25zb2xlLmdyb3VwRW5kO1xuICAgICAgICAgIHZhciB0ID0ge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgdmFsdWU6IEMsXG4gICAgICAgICAgICB3cml0YWJsZTogITBcbiAgICAgICAgICB9O1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgICAgIGluZm86IHQsXG4gICAgICAgICAgICBsb2c6IHQsXG4gICAgICAgICAgICB3YXJuOiB0LFxuICAgICAgICAgICAgZXJyb3I6IHQsXG4gICAgICAgICAgICBncm91cDogdCxcbiAgICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiB0LFxuICAgICAgICAgICAgZ3JvdXBFbmQ6IHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBCKys7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFAoKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChCLS0sIEIgPT09IDApIHtcbiAgICAgICAgICB2YXIgdCA9IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgICAgIH07XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICAgICAgbG9nOiByZSh7fSwgdCwge1xuICAgICAgICAgICAgICB2YWx1ZTogdWVcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgaW5mbzogcmUoe30sIHQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGRcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgd2FybjogcmUoe30sIHQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGxlXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGVycm9yOiByZSh7fSwgdCwge1xuICAgICAgICAgICAgICB2YWx1ZTogU2VcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZ3JvdXA6IHJlKHt9LCB0LCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBuXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiByZSh7fSwgdCwge1xuICAgICAgICAgICAgICB2YWx1ZTogc1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBncm91cEVuZDogcmUoe30sIHQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGhcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgQiA8IDAgJiYgTChcImRpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBqID0gb2UuUmVhY3RDdXJyZW50RGlzcGF0Y2hlciwgVDtcbiAgICBmdW5jdGlvbiB3KHQsIGksIGYpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKFQgPT09IHZvaWQgMClcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICB9IGNhdGNoIChSKSB7XG4gICAgICAgICAgICB2YXIgYyA9IFIuc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgICAgICBUID0gYyAmJiBjWzFdIHx8IFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICByZXR1cm4gYFxuYCArIFQgKyB0O1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgVSA9ICExLCBtZTtcbiAgICB7XG4gICAgICB2YXIgeXIgPSB0eXBlb2YgV2Vha01hcCA9PSBcImZ1bmN0aW9uXCIgPyBXZWFrTWFwIDogTWFwO1xuICAgICAgbWUgPSBuZXcgeXIoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSmUodCwgaSkge1xuICAgICAgaWYgKCF0IHx8IFUpXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAge1xuICAgICAgICB2YXIgZiA9IG1lLmdldCh0KTtcbiAgICAgICAgaWYgKGYgIT09IHZvaWQgMClcbiAgICAgICAgICByZXR1cm4gZjtcbiAgICAgIH1cbiAgICAgIHZhciBjO1xuICAgICAgVSA9ICEwO1xuICAgICAgdmFyIFIgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTtcbiAgICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdm9pZCAwO1xuICAgICAgdmFyIFM7XG4gICAgICBTID0gai5jdXJyZW50LCBqLmN1cnJlbnQgPSBudWxsLCBfKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoaSkge1xuICAgICAgICAgIHZhciBiID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLnByb3RvdHlwZSwgXCJwcm9wc1wiLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCB0eXBlb2YgUmVmbGVjdCA9PSBcIm9iamVjdFwiICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChiLCBbXSk7XG4gICAgICAgICAgICB9IGNhdGNoIChzZSkge1xuICAgICAgICAgICAgICBjID0gc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdCh0LCBbXSwgYik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGIuY2FsbCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoc2UpIHtcbiAgICAgICAgICAgICAgYyA9IHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdC5jYWxsKGIucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoc2UpIHtcbiAgICAgICAgICAgIGMgPSBzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdCgpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChzZSkge1xuICAgICAgICBpZiAoc2UgJiYgYyAmJiB0eXBlb2Ygc2Uuc3RhY2sgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGZvciAodmFyIG0gPSBzZS5zdGFjay5zcGxpdChgXG5gKSwgeiA9IGMuc3RhY2suc3BsaXQoYFxuYCksIEYgPSBtLmxlbmd0aCAtIDEsIFYgPSB6Lmxlbmd0aCAtIDE7IEYgPj0gMSAmJiBWID49IDAgJiYgbVtGXSAhPT0geltWXTsgKVxuICAgICAgICAgICAgVi0tO1xuICAgICAgICAgIGZvciAoOyBGID49IDEgJiYgViA+PSAwOyBGLS0sIFYtLSlcbiAgICAgICAgICAgIGlmIChtW0ZdICE9PSB6W1ZdKSB7XG4gICAgICAgICAgICAgIGlmIChGICE9PSAxIHx8IFYgIT09IDEpXG4gICAgICAgICAgICAgICAgZG9cbiAgICAgICAgICAgICAgICAgIGlmIChGLS0sIFYtLSwgViA8IDAgfHwgbVtGXSAhPT0geltWXSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGUgPSBgXG5gICsgbVtGXS5yZXBsYWNlKFwiIGF0IG5ldyBcIiwgXCIgYXQgXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdC5kaXNwbGF5TmFtZSAmJiB0ZS5pbmNsdWRlcyhcIjxhbm9ueW1vdXM+XCIpICYmICh0ZSA9IHRlLnJlcGxhY2UoXCI8YW5vbnltb3VzPlwiLCB0LmRpc3BsYXlOYW1lKSksIHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIiAmJiBtZS5zZXQodCwgdGUpLCB0ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoRiA+PSAxICYmIFYgPj0gMCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBVID0gITEsIGouY3VycmVudCA9IFMsIFAoKSwgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBSO1xuICAgICAgfVxuICAgICAgdmFyIEVlID0gdCA/IHQuZGlzcGxheU5hbWUgfHwgdC5uYW1lIDogXCJcIiwgdXIgPSBFZSA/IHcoRWUpIDogXCJcIjtcbiAgICAgIHJldHVybiB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIgJiYgbWUuc2V0KHQsIHVyKSwgdXI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEZlKHQsIGksIGYpIHtcbiAgICAgIHJldHVybiBKZSh0LCAhMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhyKHQpIHtcbiAgICAgIHZhciBpID0gdC5wcm90b3R5cGU7XG4gICAgICByZXR1cm4gISEoaSAmJiBpLmlzUmVhY3RDb21wb25lbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiAkZSh0LCBpLCBmKSB7XG4gICAgICBpZiAodCA9PSBudWxsKVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIGlmICh0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHJldHVybiBKZSh0LCBocih0KSk7XG4gICAgICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIHcodCk7XG4gICAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgY2FzZSBKOlxuICAgICAgICAgIHJldHVybiB3KFwiU3VzcGVuc2VcIik7XG4gICAgICAgIGNhc2UgSTpcbiAgICAgICAgICByZXR1cm4gdyhcIlN1c3BlbnNlTGlzdFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdCA9PSBcIm9iamVjdFwiKVxuICAgICAgICBzd2l0Y2ggKHQuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIEQ6XG4gICAgICAgICAgICByZXR1cm4gRmUodC5yZW5kZXIpO1xuICAgICAgICAgIGNhc2UgVzpcbiAgICAgICAgICAgIHJldHVybiAkZSh0LnR5cGUsIGksIGYpO1xuICAgICAgICAgIGNhc2UgWDoge1xuICAgICAgICAgICAgdmFyIGMgPSB0LCBSID0gYy5fcGF5bG9hZCwgUyA9IGMuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gJGUoUyhSKSwgaSwgZik7XG4gICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICB2YXIgVGUgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBPZSA9IHt9LCBYZSA9IG9lLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgZnVuY3Rpb24gUGUodCkge1xuICAgICAgaWYgKHQpIHtcbiAgICAgICAgdmFyIGkgPSB0Ll9vd25lciwgZiA9ICRlKHQudHlwZSwgdC5fc291cmNlLCBpID8gaS50eXBlIDogbnVsbCk7XG4gICAgICAgIFhlLnNldEV4dHJhU3RhY2tGcmFtZShmKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBYZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlKHQsIGksIGYsIGMsIFIpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIFMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoVGUpO1xuICAgICAgICBmb3IgKHZhciBiIGluIHQpXG4gICAgICAgICAgaWYgKFModCwgYikpIHtcbiAgICAgICAgICAgIHZhciBtID0gdm9pZCAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0W2JdICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHZhciB6ID0gRXJyb3IoKGMgfHwgXCJSZWFjdCBjbGFzc1wiKSArIFwiOiBcIiArIGYgKyBcIiB0eXBlIGBcIiArIGIgKyBcImAgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYFwiICsgdHlwZW9mIHRbYl0gKyBcImAuVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuXCIpO1xuICAgICAgICAgICAgICAgIHRocm93IHoubmFtZSA9IFwiSW52YXJpYW50IFZpb2xhdGlvblwiLCB6O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG0gPSB0W2JdKGksIGIsIGMsIGYsIG51bGwsIFwiU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRURcIik7XG4gICAgICAgICAgICB9IGNhdGNoIChGKSB7XG4gICAgICAgICAgICAgIG0gPSBGO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbSAmJiAhKG0gaW5zdGFuY2VvZiBFcnJvcikgJiYgKFBlKFIpLCBMKFwiJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuIFlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyIGNyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLlwiLCBjIHx8IFwiUmVhY3QgY2xhc3NcIiwgZiwgYiwgdHlwZW9mIG0pLCBQZShudWxsKSksIG0gaW5zdGFuY2VvZiBFcnJvciAmJiAhKG0ubWVzc2FnZSBpbiBPZSkgJiYgKE9lW20ubWVzc2FnZV0gPSAhMCwgUGUoUiksIEwoXCJGYWlsZWQgJXMgdHlwZTogJXNcIiwgZiwgbS5tZXNzYWdlKSwgUGUobnVsbCkpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGtlID0gQXJyYXkuaXNBcnJheTtcbiAgICBmdW5jdGlvbiBMZSh0KSB7XG4gICAgICByZXR1cm4ga2UodCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFFlKHQpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIGkgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wudG9TdHJpbmdUYWcsIGYgPSBpICYmIHRbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB0LmNvbnN0cnVjdG9yLm5hbWUgfHwgXCJPYmplY3RcIjtcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFplKHQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBWZSh0KSwgITE7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBWZSh0KSB7XG4gICAgICByZXR1cm4gXCJcIiArIHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFllKHQpIHtcbiAgICAgIGlmIChaZSh0KSlcbiAgICAgICAgcmV0dXJuIEwoXCJUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIiwgUWUodCkpLCBWZSh0KTtcbiAgICB9XG4gICAgdmFyIGdlID0gb2UuUmVhY3RDdXJyZW50T3duZXIsIG1yID0ge1xuICAgICAga2V5OiAhMCxcbiAgICAgIHJlZjogITAsXG4gICAgICBfX3NlbGY6ICEwLFxuICAgICAgX19zb3VyY2U6ICEwXG4gICAgfSwgZXIsIHJyLCBqZTtcbiAgICBqZSA9IHt9O1xuICAgIGZ1bmN0aW9uIGdyKHQpIHtcbiAgICAgIGlmIChUZS5jYWxsKHQsIFwicmVmXCIpKSB7XG4gICAgICAgIHZhciBpID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCBcInJlZlwiKS5nZXQ7XG4gICAgICAgIGlmIChpICYmIGkuaXNSZWFjdFdhcm5pbmcpXG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHQucmVmICE9PSB2b2lkIDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9yKHQpIHtcbiAgICAgIGlmIChUZS5jYWxsKHQsIFwia2V5XCIpKSB7XG4gICAgICAgIHZhciBpID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCBcImtleVwiKS5nZXQ7XG4gICAgICAgIGlmIChpICYmIGkuaXNSZWFjdFdhcm5pbmcpXG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHQua2V5ICE9PSB2b2lkIDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJyKHQsIGkpIHtcbiAgICAgIGlmICh0eXBlb2YgdC5yZWYgPT0gXCJzdHJpbmdcIiAmJiBnZS5jdXJyZW50ICYmIGkgJiYgZ2UuY3VycmVudC5zdGF0ZU5vZGUgIT09IGkpIHtcbiAgICAgICAgdmFyIGYgPSBaKGdlLmN1cnJlbnQudHlwZSk7XG4gICAgICAgIGplW2ZdIHx8IChMKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuIFRoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uIFdlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiBMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgWihnZS5jdXJyZW50LnR5cGUpLCB0LnJlZiksIGplW2ZdID0gITApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBfZSh0LCBpKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBmID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZXIgfHwgKGVyID0gITAsIEwoXCIlczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lIHZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgcHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKVwiLCBpKSk7XG4gICAgICAgIH07XG4gICAgICAgIGYuaXNSZWFjdFdhcm5pbmcgPSAhMCwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwia2V5XCIsIHtcbiAgICAgICAgICBnZXQ6IGYsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdHIodCwgaSkge1xuICAgICAge1xuICAgICAgICB2YXIgZiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJyIHx8IChyciA9ICEwLCBMKFwiJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSB2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50IHByb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcylcIiwgaSkpO1xuICAgICAgICB9O1xuICAgICAgICBmLmlzUmVhY3RXYXJuaW5nID0gITAsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcInJlZlwiLCB7XG4gICAgICAgICAgZ2V0OiBmLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBFciA9IGZ1bmN0aW9uKHQsIGksIGYsIGMsIFIsIFMsIGIpIHtcbiAgICAgIHZhciBtID0ge1xuICAgICAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAgICAgJCR0eXBlb2Y6IHYsXG4gICAgICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICAgICAgdHlwZTogdCxcbiAgICAgICAga2V5OiBpLFxuICAgICAgICByZWY6IGYsXG4gICAgICAgIHByb3BzOiBiLFxuICAgICAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgICAgICBfb3duZXI6IFNcbiAgICAgIH07XG4gICAgICByZXR1cm4gbS5fc3RvcmUgPSB7fSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KG0uX3N0b3JlLCBcInZhbGlkYXRlZFwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiAhMVxuICAgICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtLCBcIl9zZWxmXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMSxcbiAgICAgICAgdmFsdWU6IGNcbiAgICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkobSwgXCJfc291cmNlXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMSxcbiAgICAgICAgdmFsdWU6IFJcbiAgICAgIH0pLCBPYmplY3QuZnJlZXplICYmIChPYmplY3QuZnJlZXplKG0ucHJvcHMpLCBPYmplY3QuZnJlZXplKG0pKSwgbTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIFJyKHQsIGksIGYsIGMsIFIpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIFMsIGIgPSB7fSwgbSA9IG51bGwsIHogPSBudWxsO1xuICAgICAgICBmICE9PSB2b2lkIDAgJiYgKFllKGYpLCBtID0gXCJcIiArIGYpLCBfcihpKSAmJiAoWWUoaS5rZXkpLCBtID0gXCJcIiArIGkua2V5KSwgZ3IoaSkgJiYgKHogPSBpLnJlZiwgYnIoaSwgUikpO1xuICAgICAgICBmb3IgKFMgaW4gaSlcbiAgICAgICAgICBUZS5jYWxsKGksIFMpICYmICFtci5oYXNPd25Qcm9wZXJ0eShTKSAmJiAoYltTXSA9IGlbU10pO1xuICAgICAgICBpZiAodCAmJiB0LmRlZmF1bHRQcm9wcykge1xuICAgICAgICAgIHZhciBGID0gdC5kZWZhdWx0UHJvcHM7XG4gICAgICAgICAgZm9yIChTIGluIEYpXG4gICAgICAgICAgICBiW1NdID09PSB2b2lkIDAgJiYgKGJbU10gPSBGW1NdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobSB8fCB6KSB7XG4gICAgICAgICAgdmFyIFYgPSB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIgPyB0LmRpc3BsYXlOYW1lIHx8IHQubmFtZSB8fCBcIlVua25vd25cIiA6IHQ7XG4gICAgICAgICAgbSAmJiBfZShiLCBWKSwgeiAmJiB0cihiLCBWKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRXIodCwgbSwgeiwgUiwgYywgZ2UuY3VycmVudCwgYik7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBOZSA9IG9lLlJlYWN0Q3VycmVudE93bmVyLCBuciA9IG9lLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgZnVuY3Rpb24geWUodCkge1xuICAgICAgaWYgKHQpIHtcbiAgICAgICAgdmFyIGkgPSB0Ll9vd25lciwgZiA9ICRlKHQudHlwZSwgdC5fc291cmNlLCBpID8gaS50eXBlIDogbnVsbCk7XG4gICAgICAgIG5yLnNldEV4dHJhU3RhY2tGcmFtZShmKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBuci5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICAgIHZhciBBZTtcbiAgICBBZSA9ICExO1xuICAgIGZ1bmN0aW9uIGJlKHQpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQgIT09IG51bGwgJiYgdC4kJHR5cGVvZiA9PT0gdjtcbiAgICB9XG4gICAgZnVuY3Rpb24geGUoKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChOZS5jdXJyZW50KSB7XG4gICAgICAgICAgdmFyIHQgPSBaKE5lLmN1cnJlbnQudHlwZSk7XG4gICAgICAgICAgaWYgKHQpXG4gICAgICAgICAgICByZXR1cm4gYFxuXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBcXGBgICsgdCArIFwiYC5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gQ3IodCkge1xuICAgICAge1xuICAgICAgICBpZiAodCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgdmFyIGkgPSB0LmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sIFwiXCIpLCBmID0gdC5saW5lTnVtYmVyO1xuICAgICAgICAgIHJldHVybiBgXG5cbkNoZWNrIHlvdXIgY29kZSBhdCBgICsgaSArIFwiOlwiICsgZiArIFwiLlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgYXIgPSB7fTtcbiAgICBmdW5jdGlvbiB3cih0KSB7XG4gICAgICB7XG4gICAgICAgIHZhciBpID0geGUoKTtcbiAgICAgICAgaWYgKCFpKSB7XG4gICAgICAgICAgdmFyIGYgPSB0eXBlb2YgdCA9PSBcInN0cmluZ1wiID8gdCA6IHQuZGlzcGxheU5hbWUgfHwgdC5uYW1lO1xuICAgICAgICAgIGYgJiYgKGkgPSBgXG5cbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPGAgKyBmICsgXCI+LlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb3IodCwgaSkge1xuICAgICAge1xuICAgICAgICBpZiAoIXQuX3N0b3JlIHx8IHQuX3N0b3JlLnZhbGlkYXRlZCB8fCB0LmtleSAhPSBudWxsKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdC5fc3RvcmUudmFsaWRhdGVkID0gITA7XG4gICAgICAgIHZhciBmID0gd3IoaSk7XG4gICAgICAgIGlmIChhcltmXSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGFyW2ZdID0gITA7XG4gICAgICAgIHZhciBjID0gXCJcIjtcbiAgICAgICAgdCAmJiB0Ll9vd25lciAmJiB0Ll9vd25lciAhPT0gTmUuY3VycmVudCAmJiAoYyA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgWih0Ll9vd25lci50eXBlKSArIFwiLlwiKSwgeWUodCksIEwoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4lcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGYsIGMpLCB5ZShudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaXIodCwgaSkge1xuICAgICAge1xuICAgICAgICBpZiAodHlwZW9mIHQgIT0gXCJvYmplY3RcIilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChMZSh0KSlcbiAgICAgICAgICBmb3IgKHZhciBmID0gMDsgZiA8IHQubGVuZ3RoOyBmKyspIHtcbiAgICAgICAgICAgIHZhciBjID0gdFtmXTtcbiAgICAgICAgICAgIGJlKGMpICYmIG9yKGMsIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYmUodCkpXG4gICAgICAgICAgdC5fc3RvcmUgJiYgKHQuX3N0b3JlLnZhbGlkYXRlZCA9ICEwKTtcbiAgICAgICAgZWxzZSBpZiAodCkge1xuICAgICAgICAgIHZhciBSID0gYWUodCk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBSID09IFwiZnVuY3Rpb25cIiAmJiBSICE9PSB0LmVudHJpZXMpXG4gICAgICAgICAgICBmb3IgKHZhciBTID0gUi5jYWxsKHQpLCBiOyAhKGIgPSBTLm5leHQoKSkuZG9uZTsgKVxuICAgICAgICAgICAgICBiZShiLnZhbHVlKSAmJiBvcihiLnZhbHVlLCBpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBEZSh0KSB7XG4gICAgICB7XG4gICAgICAgIHZhciBpID0gdC50eXBlO1xuICAgICAgICBpZiAoaSA9PSBudWxsIHx8IHR5cGVvZiBpID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgZjtcbiAgICAgICAgaWYgKHR5cGVvZiBpID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICBmID0gaS5wcm9wVHlwZXM7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBpID09IFwib2JqZWN0XCIgJiYgKGkuJCR0eXBlb2YgPT09IEQgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgICAgICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cbiAgICAgICAgaS4kJHR5cGVvZiA9PT0gVykpXG4gICAgICAgICAgZiA9IGkucHJvcFR5cGVzO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoZikge1xuICAgICAgICAgIHZhciBjID0gWihpKTtcbiAgICAgICAgICBkZShmLCB0LnByb3BzLCBcInByb3BcIiwgYywgdCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaS5Qcm9wVHlwZXMgIT09IHZvaWQgMCAmJiAhQWUpIHtcbiAgICAgICAgICBBZSA9ICEwO1xuICAgICAgICAgIHZhciBSID0gWihpKTtcbiAgICAgICAgICBMKFwiQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/XCIsIFIgfHwgXCJVbmtub3duXCIpO1xuICAgICAgICB9XG4gICAgICAgIHR5cGVvZiBpLmdldERlZmF1bHRQcm9wcyA9PSBcImZ1bmN0aW9uXCIgJiYgIWkuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkICYmIEwoXCJnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gQmUodCkge1xuICAgICAge1xuICAgICAgICBmb3IgKHZhciBpID0gT2JqZWN0LmtleXModC5wcm9wcyksIGYgPSAwOyBmIDwgaS5sZW5ndGg7IGYrKykge1xuICAgICAgICAgIHZhciBjID0gaVtmXTtcbiAgICAgICAgICBpZiAoYyAhPT0gXCJjaGlsZHJlblwiICYmIGMgIT09IFwia2V5XCIpIHtcbiAgICAgICAgICAgIHllKHQpLCBMKFwiSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy5cIiwgYyksIHllKG51bGwpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHQucmVmICE9PSBudWxsICYmICh5ZSh0KSwgTChcIkludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuXCIpLCB5ZShudWxsKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHplKHQsIGksIGYsIGMsIFIsIFMpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIGIgPSBDZSh0KTtcbiAgICAgICAgaWYgKCFiKSB7XG4gICAgICAgICAgdmFyIG0gPSBcIlwiO1xuICAgICAgICAgICh0ID09PSB2b2lkIDAgfHwgdHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0ICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHQpLmxlbmd0aCA9PT0gMCkgJiYgKG0gKz0gXCIgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiKTtcbiAgICAgICAgICB2YXIgeiA9IENyKFIpO1xuICAgICAgICAgIHogPyBtICs9IHogOiBtICs9IHhlKCk7XG4gICAgICAgICAgdmFyIEY7XG4gICAgICAgICAgdCA9PT0gbnVsbCA/IEYgPSBcIm51bGxcIiA6IExlKHQpID8gRiA9IFwiYXJyYXlcIiA6IHQgIT09IHZvaWQgMCAmJiB0LiQkdHlwZW9mID09PSB2ID8gKEYgPSBcIjxcIiArIChaKHQudHlwZSkgfHwgXCJVbmtub3duXCIpICsgXCIgLz5cIiwgbSA9IFwiIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/XCIpIDogRiA9IHR5cGVvZiB0LCBMKFwiUmVhY3QuanN4OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciBidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzXCIsIEYsIG0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBWID0gUnIodCwgaSwgZiwgUiwgUyk7XG4gICAgICAgIGlmIChWID09IG51bGwpXG4gICAgICAgICAgcmV0dXJuIFY7XG4gICAgICAgIGlmIChiKSB7XG4gICAgICAgICAgdmFyIHRlID0gaS5jaGlsZHJlbjtcbiAgICAgICAgICBpZiAodGUgIT09IHZvaWQgMClcbiAgICAgICAgICAgIGlmIChjKVxuICAgICAgICAgICAgICBpZiAoTGUodGUpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgRWUgPSAwOyBFZSA8IHRlLmxlbmd0aDsgRWUrKylcbiAgICAgICAgICAgICAgICAgIGlyKHRlW0VlXSwgdCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSAmJiBPYmplY3QuZnJlZXplKHRlKTtcbiAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgTChcIlJlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuIFlvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC5cIik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGlyKHRlLCB0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdCA9PT0gRyA/IEJlKFYpIDogRGUoViksIFY7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFNyKHQsIGksIGYpIHtcbiAgICAgIHJldHVybiB6ZSh0LCBpLCBmLCAhMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFRyKHQsIGksIGYpIHtcbiAgICAgIHJldHVybiB6ZSh0LCBpLCBmLCAhMSk7XG4gICAgfVxuICAgIHZhciBPciA9IFRyLCBQciA9IFNyO1xuICAgIEhlLkZyYWdtZW50ID0gRywgSGUuanN4ID0gT3IsIEhlLmpzeHMgPSBQcjtcbiAgfSgpKSwgSGU7XG59XG5wcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBMci5leHBvcnRzID0gV3QoKSA6IExyLmV4cG9ydHMgPSBVdCgpO1xudmFyIFl0ID0gTHIuZXhwb3J0cztcbmNvbnN0IEJ0ID0gWXQuanN4O1xuZnVuY3Rpb24genQoLi4uWSkge1xuICByZXR1cm4gWS5maWx0ZXIoQm9vbGVhbikubWFwKCh2KSA9PiB2LnRyaW0oKSkuam9pbihcIiBcIik7XG59XG5jb25zdCBxdCA9IE5yLmZvcndhcmRSZWYoXG4gICh7XG4gICAgaWNvbjogWSxcbiAgICBvbkNsaWNrOiB2LFxuICAgIGFzOiBwZSxcbiAgICB3ZWlnaHQ6IEcsXG4gICAgZmlsbDogbmUgPSAhMSxcbiAgICBncmFkZTogZWUsXG4gICAgc2l6ZTogSCxcbiAgICBzdHlsZTogSyxcbiAgICBjb2xvcjogRCxcbiAgICBjbGFzc05hbWU6IEosXG4gICAgLi4uSVxuICB9LCBXKSA9PiB7XG4gICAgY29uc3QgWCA9IHYgIT09IHZvaWQgMCA/IFwiYnV0dG9uXCIgOiBwZSA/PyBcInNwYW5cIiwgayA9IHsgY29sb3I6IEQsIC4uLksgfTtcbiAgICByZXR1cm4gbmUgJiYgKGsuZm9udFZhcmlhdGlvblNldHRpbmdzID0gW2suZm9udFZhcmlhdGlvblNldHRpbmdzLCAnXCJGSUxMXCIgMSddLmZpbHRlcihCb29sZWFuKS5qb2luKFwiLCBcIikpLCBHICYmIChrLmZvbnRWYXJpYXRpb25TZXR0aW5ncyA9IFtrLmZvbnRWYXJpYXRpb25TZXR0aW5ncywgYFwid2dodFwiICR7R31gXS5maWx0ZXIoQm9vbGVhbikuam9pbihcIiwgXCIpKSwgZWUgJiYgKGsuZm9udFZhcmlhdGlvblNldHRpbmdzID0gW2suZm9udFZhcmlhdGlvblNldHRpbmdzLCBgXCJHUkFEXCIgJHtlZX1gXS5maWx0ZXIoQm9vbGVhbikuam9pbihcIiwgXCIpKSwgSCAmJiAoay5mb250VmFyaWF0aW9uU2V0dGluZ3MgPSBbay5mb250VmFyaWF0aW9uU2V0dGluZ3MsIGBcIm9wc3pcIiAke0h9YF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIsIFwiKSwgay5mb250U2l6ZSA9IEgpLCAvKiBAX19QVVJFX18gKi8gQnQoXG4gICAgICBYLFxuICAgICAge1xuICAgICAgICAuLi5JLFxuICAgICAgICByZWY6IFcsXG4gICAgICAgIHN0eWxlOiBrLFxuICAgICAgICBvbkNsaWNrOiB2LFxuICAgICAgICBjbGFzc05hbWU6IHp0KFwibWF0ZXJpYWwtc3ltYm9sc1wiLCBKKSxcbiAgICAgICAgY2hpbGRyZW46IFlcbiAgICAgIH1cbiAgICApO1xuICB9XG4pO1xuZXhwb3J0IHtcbiAgcXQgYXMgTWF0ZXJpYWxTeW1ib2xcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-material-symbols/dist/index.es.js\n");

/***/ })

};
;